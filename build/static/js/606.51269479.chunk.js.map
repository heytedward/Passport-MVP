{"version":3,"file":"static/js/606.51269479.chunk.js","mappings":"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","sources":["config/monarchRewards.js","hooks/useLimitedEditions.js","hooks/useMonarchRewards.js","components/LimitedEditionRewardModal.jsx","utils/limitedEditionQRProcessor.js","screens/ScanScreen.jsx","hooks/useReferrals.js"],"sourcesContent":["/**\n * Monarch Rewards Configuration System\n * PapillonLabs Monarch Passport MVP\n * \n * This module provides static product data for both regular and limited edition items\n * with Shopify integration, nature-themed naming, and comprehensive metadata.\n */\n\n// TypeScript-style type definitions (for documentation and IDE support)\n/**\n * @typedef {Object} ShopifyImage\n * @property {string} id - Shopify image ID\n * @property {string} src - Image URL\n * @property {string} alt - Alt text for accessibility\n * @property {number} width - Image width\n * @property {number} height - Image height\n */\n\n/**\n * @typedef {Object} LimitedEditionConfig\n * @property {number} totalSupply - Total number of items available\n * @property {number} bonusWings - Additional WINGS awarded for exclusivity\n * @property {'ultra_rare' | 'legendary' | 'mythic'} exclusivityLevel - Rarity tier\n * @property {string} [endDate] - Optional end date (ISO string)\n * @property {boolean} [isActive] - Whether the limited edition is currently active\n */\n\n/**\n * @typedef {Object} MonarchReward\n * @property {string} rewardId - Unique reward identifier\n * @property {string} name - Display name\n * @property {string} description - Detailed description\n * @property {string} category - Product category\n * @property {'common' | 'uncommon' | 'rare' | 'epic' | 'legendary' | 'mythic'} rarity - Rarity level\n * @property {number} wingsValue - Base WINGS value\n * @property {string} season - Season identifier\n * @property {boolean} isActive - Whether the reward is currently available\n * @property {ShopifyImage[]} images - Product images from Shopify\n * @property {string} shopifyProductId - Shopify product ID for integration\n * @property {number} shopifyPrice - Price in cents\n * @property {string} [shopifyHandle] - Shopify product handle for URLs\n * @property {LimitedEditionConfig} [limitedEdition] - Limited edition configuration\n * @property {Object} metadata - Additional metadata\n */\n\n// Shopify base configuration\nconst SHOPIFY_CONFIG = {\n  baseUrl: 'https://papillonbrand.us',\n  imageBaseUrl: 'https://cdn.shopify.com/s/files/1/',\n  imageSuffix: '/files/',\n  defaultImageSize: '600x600',\n  altImageSize: '1200x1200'\n};\n\n// Nature-themed color palette for Monarch Passport\nconst MONARCH_COLORS = {\n  primary: '#FFB000', // Golden Monarch\n  secondary: '#7F3FBF', // Purple Chrysalis\n  accent: '#10B981', // Green Nectar\n  dark: '#1F2937', // Dark Wing\n  light: '#F9FAFB', // Light Bloom\n  gradient: {\n    monarch: 'linear-gradient(135deg, #FFB000 0%, #FF9F1C 100%)',\n    chrysalis: 'linear-gradient(135deg, #7F3FBF 0%, #5B21B6 100%)',\n    nectar: 'linear-gradient(135deg, #10B981 0%, #059669 100%)',\n    wing: 'linear-gradient(135deg, #1F2937 0%, #111827 100%)'\n  }\n};\n\n// Exclusivity levels with descriptions\nconst EXCLUSIVITY_LEVELS = {\n  ultra_rare: {\n    name: 'Ultra Rare',\n    description: 'Extremely limited availability',\n    color: '#FFB000',\n    multiplier: 2.0\n  },\n  legendary: {\n    name: 'Legendary',\n    description: 'Legendary status with unique features',\n    color: '#7F3FBF',\n    multiplier: 3.0\n  },\n  mythic: {\n    name: 'Mythic',\n    description: 'Mythical rarity - the rarest of all',\n    color: '#10B981',\n    multiplier: 5.0\n  }\n};\n\n// Helper function to generate Shopify image URLs\nconst generateShopifyImage = (productId, imageId, filename, alt = '') => ({\n  id: imageId,\n  src: `${SHOPIFY_CONFIG.imageBaseUrl}${productId}${SHOPIFY_CONFIG.imageSuffix}${filename}?v=${Date.now()}`,\n  alt: alt,\n  width: 600,\n  height: 600,\n  srcSet: {\n    small: `${SHOPIFY_CONFIG.imageBaseUrl}${productId}${SHOPIFY_CONFIG.imageSuffix}${filename}?width=300&height=300`,\n    medium: `${SHOPIFY_CONFIG.imageBaseUrl}${productId}${SHOPIFY_CONFIG.imageSuffix}${filename}?width=600&height=600`,\n    large: `${SHOPIFY_CONFIG.imageBaseUrl}${productId}${SHOPIFY_CONFIG.imageSuffix}${filename}?width=1200&height=1200`\n  }\n});\n\n// Helper function to create limited edition configuration\nconst createLimitedEdition = (totalSupply, bonusWings, exclusivityLevel, endDate = null) => ({\n  totalSupply,\n  bonusWings,\n  exclusivityLevel,\n  endDate,\n  isActive: true\n});\n\n// Main rewards configuration\nexport const MONARCH_REWARDS = {\n  // Limited Edition Items\n  MONARCH_VARSITY_JACKET: {\n    rewardId: 'MONARCH_VARSITY_JACKET',\n    name: 'Monarch Varsity Jacket',\n    description: 'Limited edition varsity jacket featuring embroidered Monarch butterfly design with premium wool blend construction. Each piece is individually numbered and includes exclusive PapillonLabs branding.',\n    category: 'jackets',\n    rarity: 'legendary',\n    wingsValue: 150,\n    season: 'Spring2025',\n    isActive: true,\n    shopifyProductId: 'monarch-varsity-jacket-001',\n    shopifyPrice: 29900, // $299.00\n    shopifyHandle: 'monarch-varsity-jacket-limited',\n    limitedEdition: createLimitedEdition(100, 200, 'legendary', '2025-06-30T23:59:59Z'),\n    images: [\n      generateShopifyImage('monarch-varsity-jacket-001', 'img_001', 'monarch-varsity-front.jpg', 'Monarch Varsity Jacket Front View'),\n      generateShopifyImage('monarch-varsity-jacket-001', 'img_002', 'monarch-varsity-back.jpg', 'Monarch Varsity Jacket Back View'),\n      generateShopifyImage('monarch-varsity-jacket-001', 'img_003', 'monarch-varsity-detail.jpg', 'Monarch Varsity Jacket Detail')\n    ],\n    metadata: {\n      material: 'Premium wool blend',\n      fit: 'Classic varsity fit',\n      features: ['Embroidered Monarch design', 'Individual numbering', 'Exclusive branding'],\n      care: 'Dry clean only',\n      sustainability: 'Eco-friendly materials'\n    }\n  },\n\n  GOLDEN_MONARCH_CHAIN: {\n    rewardId: 'GOLDEN_MONARCH_CHAIN',\n    name: 'Golden Monarch Chain',\n    description: 'Exclusive 14k gold-plated chain featuring a handcrafted Monarch butterfly pendant. Ultra-limited release with only 50 pieces available worldwide.',\n    category: 'accessories',\n    rarity: 'mythic',\n    wingsValue: 300,\n    season: 'Spring2025',\n    isActive: true,\n    shopifyProductId: 'golden-monarch-chain-001',\n    shopifyPrice: 59900, // $599.00\n    shopifyHandle: 'golden-monarch-chain-ultra-limited',\n    limitedEdition: createLimitedEdition(50, 500, 'mythic', '2025-05-15T23:59:59Z'),\n    images: [\n      generateShopifyImage('golden-monarch-chain-001', 'img_004', 'golden-chain-front.jpg', 'Golden Monarch Chain Front View'),\n      generateShopifyImage('golden-monarch-chain-001', 'img_005', 'golden-chain-detail.jpg', 'Golden Monarch Chain Detail'),\n      generateShopifyImage('golden-monarch-chain-001', 'img_006', 'golden-chain-packaging.jpg', 'Golden Monarch Chain Packaging')\n    ],\n    metadata: {\n      material: '14k gold-plated brass',\n      chainLength: '18 inches',\n      pendantSize: '1.5 inches',\n      features: ['Handcrafted pendant', 'Limited numbering', 'Certificate of authenticity'],\n      care: 'Store in provided pouch',\n      exclusivity: 'Only 50 pieces worldwide'\n    }\n  },\n\n  CHRYSALIS_COLLECTION_HOODIE: {\n    rewardId: 'CHRYSALIS_COLLECTION_HOODIE',\n    name: 'Chrysalis Collection Hoodie',\n    description: 'Premium cotton blend hoodie featuring the Chrysalis Collection design. Limited to 200 pieces with exclusive gradient detailing.',\n    category: 'hoodies',\n    rarity: 'epic',\n    wingsValue: 100,\n    season: 'Spring2025',\n    isActive: true,\n    shopifyProductId: 'chrysalis-hoodie-001',\n    shopifyPrice: 12900, // $129.00\n    shopifyHandle: 'chrysalis-collection-hoodie',\n    limitedEdition: createLimitedEdition(200, 150, 'ultra_rare', '2025-07-31T23:59:59Z'),\n    images: [\n      generateShopifyImage('chrysalis-hoodie-001', 'img_007', 'chrysalis-hoodie-front.jpg', 'Chrysalis Hoodie Front View'),\n      generateShopifyImage('chrysalis-hoodie-001', 'img_008', 'chrysalis-hoodie-back.jpg', 'Chrysalis Hoodie Back View'),\n      generateShopifyImage('chrysalis-hoodie-001', 'img_009', 'chrysalis-hoodie-detail.jpg', 'Chrysalis Hoodie Detail')\n    ],\n    metadata: {\n      material: 'Premium cotton blend',\n      fit: 'Relaxed fit',\n      features: ['Gradient design', 'Limited edition', 'Exclusive branding'],\n      care: 'Machine wash cold',\n      sustainability: 'Organic cotton blend'\n    }\n  },\n\n  NECTAR_COLLECTION_TEE: {\n    rewardId: 'NECTAR_COLLECTION_TEE',\n    name: 'Nectar Collection Tee',\n    description: 'Classic fit t-shirt featuring the Nectar Collection design. Limited to 150 pieces with exclusive colorway.',\n    category: 'tops',\n    rarity: 'rare',\n    wingsValue: 75,\n    season: 'Spring2025',\n    isActive: true,\n    shopifyProductId: 'nectar-tee-001',\n    shopifyPrice: 4500, // $45.00\n    shopifyHandle: 'nectar-collection-tee',\n    limitedEdition: createLimitedEdition(150, 100, 'ultra_rare', '2025-08-31T23:59:59Z'),\n    images: [\n      generateShopifyImage('nectar-tee-001', 'img_010', 'nectar-tee-front.jpg', 'Nectar Tee Front View'),\n      generateShopifyImage('nectar-tee-001', 'img_011', 'nectar-tee-back.jpg', 'Nectar Tee Back View')\n    ],\n    metadata: {\n      material: '100% organic cotton',\n      fit: 'Classic fit',\n      features: ['Exclusive colorway', 'Limited edition', 'Sustainable materials'],\n      care: 'Machine wash cold',\n      sustainability: '100% organic cotton'\n    }\n  },\n\n  // Regular (Unlimited) Items\n  CLASSIC_MONARCH_TEE: {\n    rewardId: 'CLASSIC_MONARCH_TEE',\n    name: 'Classic Monarch Tee',\n    description: 'Timeless t-shirt featuring the iconic Monarch butterfly design. Made from premium organic cotton with sustainable practices.',\n    category: 'tops',\n    rarity: 'common',\n    wingsValue: 25,\n    season: 'Spring2025',\n    isActive: true,\n    shopifyProductId: 'classic-monarch-tee-001',\n    shopifyPrice: 3500, // $35.00\n    shopifyHandle: 'classic-monarch-tee',\n    images: [\n      generateShopifyImage('classic-monarch-tee-001', 'img_012', 'classic-tee-front.jpg', 'Classic Monarch Tee Front View'),\n      generateShopifyImage('classic-monarch-tee-001', 'img_013', 'classic-tee-back.jpg', 'Classic Monarch Tee Back View')\n    ],\n    metadata: {\n      material: '100% organic cotton',\n      fit: 'Classic fit',\n      features: ['Iconic Monarch design', 'Sustainable materials', 'Comfortable fit'],\n      care: 'Machine wash cold',\n      sustainability: '100% organic cotton'\n    }\n  },\n\n  MONARCH_SNAPBACK: {\n    rewardId: 'MONARCH_SNAPBACK',\n    name: 'Monarch Snapback',\n    description: 'Classic snapback cap featuring embroidered Monarch butterfly design. Adjustable fit with premium construction.',\n    category: 'headwear',\n    rarity: 'uncommon',\n    wingsValue: 40,\n    season: 'Spring2025',\n    isActive: true,\n    shopifyProductId: 'monarch-snapback-001',\n    shopifyPrice: 2800, // $28.00\n    shopifyHandle: 'monarch-snapback',\n    images: [\n      generateShopifyImage('monarch-snapback-001', 'img_014', 'snapback-front.jpg', 'Monarch Snapback Front View'),\n      generateShopifyImage('monarch-snapback-001', 'img_015', 'snapback-side.jpg', 'Monarch Snapback Side View')\n    ],\n    metadata: {\n      material: 'Premium cotton twill',\n      fit: 'Adjustable snapback',\n      features: ['Embroidered design', 'Adjustable fit', 'Premium construction'],\n      care: 'Spot clean only',\n      sustainability: 'Sustainable materials'\n    }\n  },\n\n  WING_COLLECTION_PINS: {\n    rewardId: 'WING_COLLECTION_PINS',\n    name: 'Wing Collection Pin Set',\n    description: 'Collectible enamel pin set featuring various butterfly wing designs. Perfect for collectors and enthusiasts.',\n    category: 'accessories',\n    rarity: 'rare',\n    wingsValue: 60,\n    season: 'Spring2025',\n    isActive: true,\n    shopifyProductId: 'wing-pins-001',\n    shopifyPrice: 1800, // $18.00\n    shopifyHandle: 'wing-collection-pins',\n    images: [\n      generateShopifyImage('wing-pins-001', 'img_016', 'wing-pins-set.jpg', 'Wing Collection Pin Set'),\n      generateShopifyImage('wing-pins-001', 'img_017', 'wing-pins-individual.jpg', 'Individual Wing Pins')\n    ],\n    metadata: {\n      material: 'Enamel on metal',\n      setSize: '5 pins',\n      features: ['Collectible design', 'Enamel finish', 'Display case included'],\n      care: 'Store in provided case',\n      collectibility: 'Limited production runs'\n    }\n  },\n\n  BLOOM_COLLECTION_HOODIE: {\n    rewardId: 'BLOOM_COLLECTION_HOODIE',\n    name: 'Bloom Collection Hoodie',\n    description: 'Cozy pullover hoodie featuring the Bloom Collection design. Made from sustainable materials with comfortable fit.',\n    category: 'hoodies',\n    rarity: 'uncommon',\n    wingsValue: 80,\n    season: 'Spring2025',\n    isActive: true,\n    shopifyProductId: 'bloom-hoodie-001',\n    shopifyPrice: 8900, // $89.00\n    shopifyHandle: 'bloom-collection-hoodie',\n    images: [\n      generateShopifyImage('bloom-hoodie-001', 'img_018', 'bloom-hoodie-front.jpg', 'Bloom Hoodie Front View'),\n      generateShopifyImage('bloom-hoodie-001', 'img_019', 'bloom-hoodie-back.jpg', 'Bloom Hoodie Back View')\n    ],\n    metadata: {\n      material: 'Sustainable cotton blend',\n      fit: 'Relaxed fit',\n      features: ['Bloom design', 'Sustainable materials', 'Comfortable fit'],\n      care: 'Machine wash cold',\n      sustainability: 'Sustainable cotton blend'\n    }\n  },\n\n  POLLINATE_COLLECTION_BAG: {\n    rewardId: 'POLLINATE_COLLECTION_BAG',\n    name: 'Pollinate Collection Bag',\n    description: 'Eco-friendly tote bag featuring the Pollinate Collection design. Perfect for everyday use with sustainable construction.',\n    category: 'accessories',\n    rarity: 'common',\n    wingsValue: 30,\n    season: 'Spring2025',\n    isActive: true,\n    shopifyProductId: 'pollinate-bag-001',\n    shopifyPrice: 2200, // $22.00\n    shopifyHandle: 'pollinate-collection-bag',\n    images: [\n      generateShopifyImage('pollinate-bag-001', 'img_020', 'pollinate-bag-front.jpg', 'Pollinate Bag Front View'),\n      generateShopifyImage('pollinate-bag-001', 'img_021', 'pollinate-bag-interior.jpg', 'Pollinate Bag Interior')\n    ],\n    metadata: {\n      material: 'Recycled canvas',\n      dimensions: '15\" x 12\" x 4\"',\n      features: ['Eco-friendly design', 'Recycled materials', 'Spacious interior'],\n      care: 'Spot clean only',\n      sustainability: '100% recycled materials'\n    }\n  },\n\n  // Additional rewards to match QR generator\n  MONARCH_SNAPBACK_CAP: {\n    rewardId: 'MONARCH_SNAPBACK_CAP',\n    name: 'Monarch Snapback Cap',\n    description: 'Embroidered snapback cap with adjustable strap and metallic butterfly accent',\n    category: 'headwear',\n    rarity: 'uncommon',\n    wingsValue: 35,\n    season: 'Spring2025',\n    isActive: true,\n    shopifyProductId: 'monarch-snapback-cap-001',\n    shopifyPrice: 2800, // $28.00\n    shopifyHandle: 'monarch-snapback-cap',\n    images: [\n      generateShopifyImage('monarch-snapback-cap-001', 'img_022', 'snapback-cap-front.jpg', 'Monarch Snapback Cap Front View'),\n      generateShopifyImage('monarch-snapback-cap-001', 'img_023', 'snapback-cap-side.jpg', 'Monarch Snapback Cap Side View')\n    ],\n    metadata: {\n      material: 'Premium cotton twill',\n      fit: 'Adjustable snapback',\n      features: ['Embroidered design', 'Adjustable fit', 'Metallic accent'],\n      care: 'Spot clean only',\n      sustainability: 'Sustainable materials'\n    }\n  },\n\n  MONARCH_PIN_SET: {\n    rewardId: 'MONARCH_PIN_SET',\n    name: 'Monarch Pin Set',\n    description: 'Collectible enamel pin set featuring butterfly designs and exclusive packaging',\n    category: 'accessories',\n    rarity: 'rare',\n    wingsValue: 45,\n    season: 'Spring2025',\n    isActive: true,\n    shopifyProductId: 'monarch-pin-set-001',\n    shopifyPrice: 1800, // $18.00\n    shopifyHandle: 'monarch-pin-set',\n    images: [\n      generateShopifyImage('monarch-pin-set-001', 'img_024', 'monarch-pin-set.jpg', 'Monarch Pin Set'),\n      generateShopifyImage('monarch-pin-set-001', 'img_025', 'monarch-pin-individual.jpg', 'Individual Monarch Pins')\n    ],\n    metadata: {\n      material: 'Enamel on metal',\n      setSize: '3 pins',\n      features: ['Collectible design', 'Enamel finish', 'Exclusive packaging'],\n      care: 'Store in provided case',\n      collectibility: 'Limited production runs'\n    }\n  },\n\n  MONARCH_BACKPACK: {\n    rewardId: 'MONARCH_BACKPACK',\n    name: 'Monarch Backpack',\n    description: 'Functional backpack with butterfly wing design and premium materials',\n    category: 'accessories',\n    rarity: 'rare',\n    wingsValue: 45,\n    season: 'Spring2025',\n    isActive: true,\n    shopifyProductId: 'monarch-backpack-001',\n    shopifyPrice: 4500, // $45.00\n    shopifyHandle: 'monarch-backpack',\n    images: [\n      generateShopifyImage('monarch-backpack-001', 'img_026', 'monarch-backpack-front.jpg', 'Monarch Backpack Front View'),\n      generateShopifyImage('monarch-backpack-001', 'img_027', 'monarch-backpack-interior.jpg', 'Monarch Backpack Interior')\n    ],\n    metadata: {\n      material: 'Premium canvas',\n      dimensions: '16\" x 12\" x 6\"',\n      features: ['Butterfly wing design', 'Premium materials', 'Spacious interior'],\n      care: 'Spot clean only',\n      sustainability: 'Sustainable materials'\n    }\n  }\n};\n\n// Utility functions for working with rewards\nexport const RewardUtils = {\n  /**\n   * Get all active rewards\n   * @returns {MonarchReward[]}\n   */\n  getActiveRewards() {\n    return Object.values(MONARCH_REWARDS).filter(reward => reward.isActive);\n  },\n\n  /**\n   * Get all limited edition rewards\n   * @returns {MonarchReward[]}\n   */\n  getLimitedEditionRewards() {\n    return Object.values(MONARCH_REWARDS).filter(reward => \n      reward.isActive && reward.limitedEdition\n    );\n  },\n\n  /**\n   * Get all regular (unlimited) rewards\n   * @returns {MonarchReward[]}\n   */\n  getRegularRewards() {\n    return Object.values(MONARCH_REWARDS).filter(reward => \n      reward.isActive && !reward.limitedEdition\n    );\n  },\n\n  /**\n   * Get reward by ID\n   * @param {string} rewardId\n   * @returns {MonarchReward|null}\n   */\n  getRewardById(rewardId) {\n    return MONARCH_REWARDS[rewardId] || null;\n  },\n\n  /**\n   * Get rewards by category\n   * @param {string} category\n   * @returns {MonarchReward[]}\n   */\n  getRewardsByCategory(category) {\n    return Object.values(MONARCH_REWARDS).filter(reward => \n      reward.isActive && reward.category === category\n    );\n  },\n\n  /**\n   * Get rewards by rarity\n   * @param {string} rarity\n   * @returns {MonarchReward[]}\n   */\n  getRewardsByRarity(rarity) {\n    return Object.values(MONARCH_REWARDS).filter(reward => \n      reward.isActive && reward.rarity === rarity\n    );\n  },\n\n  /**\n   * Get rewards by season\n   * @param {string} season\n   * @returns {MonarchReward[]}\n   */\n  getRewardsBySeason(season) {\n    return Object.values(MONARCH_REWARDS).filter(reward => \n      reward.isActive && reward.season === season\n    );\n  },\n\n  /**\n   * Check if reward is limited edition\n   * @param {string} rewardId\n   * @returns {boolean}\n   */\n  isLimitedEdition(rewardId) {\n    const reward = MONARCH_REWARDS[rewardId];\n    return reward ? !!reward.limitedEdition : false;\n  },\n\n  /**\n   * Get limited edition configuration\n   * @param {string} rewardId\n   * @returns {LimitedEditionConfig|null}\n   */\n  getLimitedEditionConfig(rewardId) {\n    const reward = MONARCH_REWARDS[rewardId];\n    return reward?.limitedEdition || null;\n  },\n\n  /**\n   * Get total WINGS value for a reward (including limited edition bonus)\n   * @param {string} rewardId\n   * @returns {number}\n   */\n  getTotalWingsValue(rewardId) {\n    const reward = MONARCH_REWARDS[rewardId];\n    if (!reward) return 0;\n\n    const baseWings = reward.wingsValue;\n    const bonusWings = reward.limitedEdition?.bonusWings || 0;\n    \n    return baseWings + bonusWings;\n  },\n\n  /**\n   * Get Shopify product URL\n   * @param {string} rewardId\n   * @returns {string|null}\n   */\n  getShopifyUrl(rewardId) {\n    const reward = MONARCH_REWARDS[rewardId];\n    if (!reward?.shopifyHandle) return null;\n    \n    return `${SHOPIFY_CONFIG.baseUrl}/products/${reward.shopifyHandle}`;\n  },\n\n  /**\n   * Get primary image for a reward\n   * @param {string} rewardId\n   * @returns {ShopifyImage|null}\n   */\n  getPrimaryImage(rewardId) {\n    const reward = MONARCH_REWARDS[rewardId];\n    return reward?.images?.[0] || null;\n  },\n\n  /**\n   * Get exclusivity level info\n   * @param {string} level\n   * @returns {Object|null}\n   */\n  getExclusivityLevel(level) {\n    return EXCLUSIVITY_LEVELS[level] || null;\n  },\n\n  /**\n   * Get all exclusivity levels\n   * @returns {Object}\n   */\n  getAllExclusivityLevels() {\n    return EXCLUSIVITY_LEVELS;\n  },\n\n  /**\n   * Get Monarch color palette\n   * @returns {Object}\n   */\n  getMonarchColors() {\n    return MONARCH_COLORS;\n  }\n};\n\n// Export configuration constants\nexport const REWARD_CONFIG = {\n  SHOPIFY_CONFIG,\n  MONARCH_COLORS,\n  EXCLUSIVITY_LEVELS\n};\n\n// Default export\nexport default MONARCH_REWARDS; ","import { useState, useEffect, useCallback } from 'react';\nimport { createClient } from '@supabase/supabase-js';\n\nconst supabase = createClient(\n  process.env.REACT_APP_SUPABASE_URL,\n  process.env.REACT_APP_SUPABASE_ANON_KEY\n);\n\nexport const useLimitedEditions = () => {\n  const [activeLimitedEditions, setActiveLimitedEditions] = useState([]);\n  const [userClaims, setUserClaims] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  // Fetch active limited editions\n  const fetchActiveLimitedEditions = useCallback(async () => {\n    try {\n      setLoading(true);\n      setError(null);\n\n      const { data, error } = await supabase\n        .rpc('get_active_limited_editions');\n\n      if (error) throw error;\n\n      setActiveLimitedEditions(data || []);\n    } catch (err) {\n      console.error('Error fetching active limited editions:', err);\n      setError(err.message);\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // Fetch user's limited edition claims\n  const fetchUserClaims = useCallback(async () => {\n    try {\n      const { data: { user } } = await supabase.auth.getUser();\n      if (!user) return;\n\n      const { data, error } = await supabase\n        .rpc('get_user_limited_editions', { p_user_id: user.id });\n\n      if (error) throw error;\n\n      setUserClaims(data || []);\n    } catch (err) {\n      console.error('Error fetching user claims:', err);\n      setError(err.message);\n    }\n  }, []);\n\n  // Claim a limited edition item\n  const claimLimitedEdition = useCallback(async (rewardId, qrScanLocation = null) => {\n    try {\n      setError(null);\n      \n      const { data: { user } } = await supabase.auth.getUser();\n      if (!user) {\n        throw new Error('User not authenticated');\n      }\n\n      const { data, error } = await supabase\n        .rpc('claim_limited_edition_item', {\n          p_reward_id: rewardId,\n          p_user_id: user.id,\n          p_qr_scan_location: qrScanLocation\n        });\n\n      if (error) throw error;\n\n      if (data && data.length > 0) {\n        const result = data[0];\n        \n        if (result.success) {\n          // Refresh data after successful claim\n          await Promise.all([\n            fetchActiveLimitedEditions(),\n            fetchUserClaims()\n          ]);\n          \n          return {\n            success: true,\n            mintNumber: result.mint_number,\n            claimedAt: result.claimed_at,\n            message: result.message\n          };\n        } else {\n          return {\n            success: false,\n            message: result.message\n          };\n        }\n      }\n\n      return {\n        success: false,\n        message: 'Unknown error occurred'\n      };\n    } catch (err) {\n      console.error('Error claiming limited edition:', err);\n      setError(err.message);\n      return {\n        success: false,\n        message: err.message\n      };\n    }\n  }, [fetchActiveLimitedEditions, fetchUserClaims]);\n\n  // Get status of a specific limited edition\n  const getLimitedEditionStatus = useCallback(async (rewardId) => {\n    try {\n      const { data, error } = await supabase\n        .rpc('get_limited_edition_status', { p_reward_id: rewardId });\n\n      if (error) throw error;\n\n      return data && data.length > 0 ? data[0] : null;\n    } catch (err) {\n      console.error('Error getting limited edition status:', err);\n      setError(err.message);\n      return null;\n    }\n  }, []);\n\n  // Check if user has claimed a specific limited edition\n  const hasUserClaimed = useCallback((rewardId) => {\n    return userClaims.some(claim => claim.reward_id === rewardId);\n  }, [userClaims]);\n\n  // Get user's mint number for a specific limited edition\n  const getUserMintNumber = useCallback((rewardId) => {\n    const claim = userClaims.find(claim => claim.reward_id === rewardId);\n    return claim ? claim.mint_number : null;\n  }, [userClaims]);\n\n  // Load initial data\n  useEffect(() => {\n    const loadData = async () => {\n      await Promise.all([\n        fetchActiveLimitedEditions(),\n        fetchUserClaims()\n      ]);\n    };\n\n    loadData();\n  }, [fetchActiveLimitedEditions, fetchUserClaims]);\n\n  // Refresh data\n  const refresh = useCallback(async () => {\n    await Promise.all([\n      fetchActiveLimitedEditions(),\n      fetchUserClaims()\n    ]);\n  }, [fetchActiveLimitedEditions, fetchUserClaims]);\n\n  return {\n    // Data\n    activeLimitedEditions,\n    userClaims,\n    loading,\n    error,\n    \n    // Actions\n    claimLimitedEdition,\n    getLimitedEditionStatus,\n    refresh,\n    \n    // Helpers\n    hasUserClaimed,\n    getUserMintNumber,\n    \n    // Computed values\n    totalUserClaims: userClaims.length,\n    availableLimitedEditions: activeLimitedEditions.filter(item => item.available_count > 0)\n  };\n};\n\n// Hook for admin functions\nexport const useLimitedEditionAdmin = () => {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  // Create a new limited edition item\n  const createLimitedEdition = useCallback(async (rewardId, totalSupply, startDate, endDate = null) => {\n    try {\n      setLoading(true);\n      setError(null);\n\n      const { data, error } = await supabase\n        .rpc('create_limited_edition_item', {\n          p_reward_id: rewardId,\n          p_total_supply: totalSupply,\n          p_start_date: startDate,\n          p_end_date: endDate\n        });\n\n      if (error) throw error;\n\n      return {\n        success: true,\n        itemId: data\n      };\n    } catch (err) {\n      console.error('Error creating limited edition:', err);\n      setError(err.message);\n      return {\n        success: false,\n        message: err.message\n      };\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // Reset limited edition for testing\n  const resetLimitedEdition = useCallback(async (rewardId) => {\n    try {\n      setLoading(true);\n      setError(null);\n\n      const { data, error } = await supabase\n        .rpc('reset_limited_edition_for_testing', { p_reward_id: rewardId });\n\n      if (error) throw error;\n\n      return {\n        success: true,\n        message: 'Limited edition reset successfully'\n      };\n    } catch (err) {\n      console.error('Error resetting limited edition:', err);\n      setError(err.message);\n      return {\n        success: false,\n        message: err.message\n      };\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // Get analytics data\n  const getAnalytics = useCallback(async () => {\n    try {\n      setLoading(true);\n      setError(null);\n\n      const { data, error } = await supabase\n        .from('limited_edition_analytics')\n        .select('*')\n        .order('created_at', { ascending: false });\n\n      if (error) throw error;\n\n      return data || [];\n    } catch (err) {\n      console.error('Error fetching analytics:', err);\n      setError(err.message);\n      return [];\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  return {\n    loading,\n    error,\n    createLimitedEdition,\n    resetLimitedEdition,\n    getAnalytics\n  };\n}; ","/**\n * Monarch Rewards Hook\n * PapillonLabs Monarch Passport MVP\n * \n * This hook combines static rewards configuration with limited edition tracking\n * to provide a unified interface for reward management.\n */\n\nimport { useState, useEffect, useCallback } from 'react';\nimport { createClient } from '@supabase/supabase-js';\nimport MONARCH_REWARDS, { RewardUtils } from '../config/monarchRewards';\nimport { useLimitedEditions } from './useLimitedEditions';\n\nconst supabase = createClient(\n  process.env.REACT_APP_SUPABASE_URL,\n  process.env.REACT_APP_SUPABASE_ANON_KEY\n);\n\nexport const useMonarchRewards = () => {\n  const [rewards, setRewards] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [userRewards, setUserRewards] = useState([]);\n  const [userLoading, setUserLoading] = useState(true);\n\n  // Use the limited editions hook\n  const {\n    activeLimitedEditions,\n    userClaims,\n    claimLimitedEdition,\n    hasUserClaimed,\n    getUserMintNumber,\n    loading: limitedEditionLoading,\n    error: limitedEditionError\n  } = useLimitedEditions();\n\n  // Load all rewards with limited edition status\n  const loadRewards = useCallback(async () => {\n    try {\n      setLoading(true);\n      setError(null);\n\n      const allRewards = RewardUtils.getActiveRewards();\n      const rewardsWithStatus = [];\n\n      for (const reward of allRewards) {\n        let limitedEditionStatus = null;\n\n        // Check if this is a limited edition reward\n        if (reward.limitedEdition) {\n          // Find matching limited edition from the hook\n          const limitedEdition = activeLimitedEditions.find(\n            le => le.reward_id === reward.rewardId\n          );\n          \n          if (limitedEdition) {\n            limitedEditionStatus = {\n              totalSupply: limitedEdition.total_supply,\n              claimedCount: limitedEdition.claimed_count,\n              availableCount: limitedEdition.available_count,\n              claimPercentage: limitedEdition.claim_percentage,\n              daysRemaining: limitedEdition.days_remaining,\n              isActive: true\n            };\n          }\n        }\n\n        rewardsWithStatus.push({\n          ...reward,\n          limitedEditionStatus,\n          isLimitedEdition: !!reward.limitedEdition,\n          userHasClaimed: hasUserClaimed(reward.rewardId),\n          userMintNumber: getUserMintNumber(reward.rewardId),\n          totalWingsValue: RewardUtils.getTotalWingsValue(reward.rewardId),\n          shopifyUrl: RewardUtils.getShopifyUrl(reward.rewardId),\n          primaryImage: RewardUtils.getPrimaryImage(reward.rewardId)\n        });\n      }\n\n      setRewards(rewardsWithStatus);\n    } catch (err) {\n      console.error('Error loading rewards:', err);\n      setError(err.message);\n    } finally {\n      setLoading(false);\n    }\n  }, [activeLimitedEditions, hasUserClaimed, getUserMintNumber]);\n\n  // Load user's rewards from closet\n  const loadUserRewards = useCallback(async () => {\n    try {\n      setUserLoading(true);\n      \n      const { data: { user } } = await supabase.auth.getUser();\n      if (!user) {\n        setUserRewards([]);\n        return;\n      }\n\n      const { data, error } = await supabase\n        .from('user_closet')\n        .select('*')\n        .eq('user_id', user.id)\n        .order('earned_date', { ascending: false });\n\n      if (error) throw error;\n\n      // Enhance user rewards with static configuration data\n      const enhancedUserRewards = (data || []).map(userReward => {\n        const staticReward = RewardUtils.getRewardById(userReward.reward_id);\n        return {\n          ...userReward,\n          staticData: staticReward,\n          isLimitedEdition: staticReward?.limitedEdition ? true : false,\n          totalWingsValue: staticReward ? RewardUtils.getTotalWingsValue(staticReward.rewardId) : userReward.wings_earned,\n          shopifyUrl: staticReward ? RewardUtils.getShopifyUrl(staticReward.rewardId) : null,\n          primaryImage: staticReward ? RewardUtils.getPrimaryImage(staticReward.rewardId) : null\n        };\n      });\n\n      setUserRewards(enhancedUserRewards);\n    } catch (err) {\n      console.error('Error loading user rewards:', err);\n      setError(err.message);\n    } finally {\n      setUserLoading(false);\n    }\n  }, []);\n\n  // Claim a reward (handles both regular and limited edition)\n  const claimReward = useCallback(async (rewardId, qrScanLocation = null) => {\n    try {\n      setError(null);\n      \n      // Add overall timeout to prevent hanging\n      const overallTimeout = new Promise((_, reject) => \n        setTimeout(() => reject(new Error('Claim operation timeout')), 10000)\n      );\n      \n      const claimOperation = (async () => {\n      \n      const reward = RewardUtils.getRewardById(rewardId);\n      if (!reward) {\n        throw new Error(`Reward not found: ${rewardId}`);\n      }\n\n      // Check if user is authenticated\n      const { data: { user } } = await supabase.auth.getUser();\n      if (!user) {\n        throw new Error('User not authenticated');\n      }\n\n      // Handle limited edition claims\n      if (reward.limitedEdition) {\n        return await claimLimitedEdition(rewardId, qrScanLocation);\n      }\n\n      // Handle regular reward claims\n      const { data, error } = await supabase\n        .from('user_closet')\n        .insert({\n          user_id: user.id,\n          reward_id: rewardId,\n          name: reward.name,\n          rarity: reward.rarity,\n          category: reward.category,\n          mint_number: 1, // Regular items don't have mint numbers\n          earned_date: new Date().toISOString(),\n          earned_via: 'qr_scan',\n          wings_earned: reward.wingsValue,\n          metadata: {\n            qr_scan_location: qrScanLocation,\n            static_reward_id: rewardId\n          }\n        })\n        .select()\n        .single();\n\n      if (error) {\n        if (error.code === '23505') { // Unique constraint violation\n          throw new Error('You have already claimed this reward');\n        }\n        throw error;\n      }\n\n      // Award WINGS\n      await supabase\n        .from('user_profiles')\n        .update({\n          wings_balance: supabase.raw('wings_balance + ?', [reward.wingsValue]),\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', user.id);\n\n      // Refresh user rewards (with timeout to prevent hanging)\n      try {\n        console.log('🔄 Refreshing user rewards...');\n        const timeoutPromise = new Promise((_, reject) => \n          setTimeout(() => reject(new Error('User rewards refresh timeout')), 3000)\n        );\n        await Promise.race([loadUserRewards(), timeoutPromise]);\n        console.log('✅ User rewards refreshed successfully');\n      } catch (refreshError) {\n        console.warn('⚠️ Failed to refresh user rewards (non-critical):', refreshError);\n        // Continue with the claim even if refresh fails\n      }\n\n        return {\n          success: true,\n          message: `Successfully claimed ${reward.name}!`,\n          reward: data\n        };\n      })();\n      \n      return await Promise.race([claimOperation, overallTimeout]);\n    } catch (err) {\n      console.error('Error claiming reward:', err);\n      setError(err.message);\n      return {\n        success: false,\n        message: err.message\n      };\n    }\n  }, [claimLimitedEdition, loadUserRewards]);\n\n  // Get rewards by category\n  const getRewardsByCategory = useCallback((category) => {\n    return rewards.filter(reward => reward.category === category);\n  }, [rewards]);\n\n  // Get rewards by rarity\n  const getRewardsByRarity = useCallback((rarity) => {\n    return rewards.filter(reward => reward.rarity === rarity);\n  }, [rewards]);\n\n  // Get limited edition rewards\n  const getLimitedEditionRewards = useCallback(() => {\n    return rewards.filter(reward => reward.isLimitedEdition);\n  }, [rewards]);\n\n  // Get regular rewards\n  const getRegularRewards = useCallback(() => {\n    return rewards.filter(reward => !reward.isLimitedEdition);\n  }, [rewards]);\n\n  // Get user's limited edition claims\n  const getUserLimitedEditions = useCallback(() => {\n    return userRewards.filter(reward => reward.isLimitedEdition);\n  }, [userRewards]);\n\n  // Get user's regular rewards\n  const getUserRegularRewards = useCallback(() => {\n    return userRewards.filter(reward => !reward.isLimitedEdition);\n  }, [userRewards]);\n\n  // Check if user can claim a reward\n  const canUserClaim = useCallback((rewardId) => {\n    const reward = rewards.find(r => r.rewardId === rewardId);\n    if (!reward) return false;\n\n    // Check if user already claimed\n    if (reward.userHasClaimed) return false;\n\n    // Check if limited edition is available\n    if (reward.isLimitedEdition && reward.limitedEditionStatus) {\n      return reward.limitedEditionStatus.availableCount > 0;\n    }\n\n    return true;\n  }, [rewards]);\n\n  // Get reward statistics\n  const getRewardStats = useCallback(() => {\n    const totalRewards = rewards.length;\n    const limitedEditions = getLimitedEditionRewards().length;\n    const regularRewards = getRegularRewards().length;\n    const userTotalRewards = userRewards.length;\n    const userLimitedEditions = getUserLimitedEditions().length;\n    const userRegularRewards = getUserRegularRewards().length;\n\n    const totalWingsValue = rewards.reduce((sum, reward) => sum + reward.totalWingsValue, 0);\n    const userTotalWings = userRewards.reduce((sum, reward) => sum + (reward.totalWingsValue || 0), 0);\n\n    return {\n      totalRewards,\n      limitedEditions,\n      regularRewards,\n      totalWingsValue,\n      userTotalRewards,\n      userLimitedEditions,\n      userRegularRewards,\n      userTotalWings,\n      claimPercentage: totalRewards > 0 ? (userTotalRewards / totalRewards) * 100 : 0\n    };\n  }, [rewards, userRewards, getLimitedEditionRewards, getRegularRewards, getUserLimitedEditions, getUserRegularRewards]);\n\n  // Load data on mount and when dependencies change\n  useEffect(() => {\n    loadRewards();\n  }, [loadRewards]);\n\n  useEffect(() => {\n    loadUserRewards();\n  }, [loadUserRewards]);\n\n  return {\n    // Data\n    rewards,\n    userRewards,\n    loading: loading || limitedEditionLoading,\n    userLoading,\n    error: error || limitedEditionError,\n    \n    // Actions\n    claimReward,\n    refresh: () => {\n      loadRewards();\n      loadUserRewards();\n    },\n    \n    // Filtered data\n    getRewardsByCategory,\n    getRewardsByRarity,\n    getLimitedEditionRewards,\n    getRegularRewards,\n    getUserLimitedEditions,\n    getUserRegularRewards,\n    \n    // Utilities\n    canUserClaim,\n    getRewardStats,\n    getRewardById: RewardUtils.getRewardById,\n    \n    // Limited edition specific\n    hasUserClaimed,\n    getUserMintNumber,\n    \n    // Computed values\n    totalRewards: rewards.length,\n    userTotalRewards: userRewards.length,\n    stats: getRewardStats()\n  };\n};\n\n// Hook for admin functions\nexport const useMonarchRewardsAdmin = () => {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  // Initialize limited editions from static configuration\n  const initializeLimitedEditions = useCallback(async () => {\n    try {\n      setLoading(true);\n      setError(null);\n\n      const { initializeLimitedEditions: initFunction } = await import('../utils/rewardIntegration');\n      const results = await initFunction();\n\n      return {\n        success: true,\n        results\n      };\n    } catch (err) {\n      console.error('Error initializing limited editions:', err);\n      setError(err.message);\n      return {\n        success: false,\n        message: err.message\n      };\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // Sync static rewards with database\n  const syncStaticRewards = useCallback(async () => {\n    try {\n      setLoading(true);\n      setError(null);\n\n      const { syncStaticRewards: syncFunction } = await import('../utils/rewardIntegration');\n      const results = await syncFunction();\n\n      return {\n        success: true,\n        results\n      };\n    } catch (err) {\n      console.error('Error syncing static rewards:', err);\n      setError(err.message);\n      return {\n        success: false,\n        message: err.message\n      };\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // Validate reward configuration\n  const validateConfiguration = useCallback(async () => {\n    try {\n      const { validateRewardConfiguration: validateFunction } = await import('../utils/rewardIntegration');\n      return validateFunction();\n    } catch (err) {\n      console.error('Error validating configuration:', err);\n      return {\n        errors: [err.message],\n        warnings: [],\n        isValid: false\n      };\n    }\n  }, []);\n\n  // Get analytics\n  const getAnalytics = useCallback(async () => {\n    try {\n      setLoading(true);\n      setError(null);\n\n      const { getRewardAnalytics: analyticsFunction } = await import('../utils/rewardIntegration');\n      const analytics = await analyticsFunction();\n\n      return {\n        success: true,\n        analytics\n      };\n    } catch (err) {\n      console.error('Error getting analytics:', err);\n      setError(err.message);\n      return {\n        success: false,\n        message: err.message\n      };\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  return {\n    loading,\n    error,\n    initializeLimitedEditions,\n    syncStaticRewards,\n    validateConfiguration,\n    getAnalytics\n  };\n}; ","/**\n * Limited Edition Reward Modal\n * PapillonLabs Monarch Passport MVP\n * \n * Enhanced modal component for displaying limited edition rewards\n * with mint numbers, exclusivity levels, enhanced visual effects,\n * social sharing hints, and collection value messaging.\n */\n\nimport React, { useState } from 'react';\nimport styled, { keyframes } from 'styled-components';\nimport GlassCard from './GlassCard';\nimport GlowButton from './GlowButton';\n\nconst limitedEditionReveal = keyframes`\n  0% { \n    opacity: 0; \n    transform: scale(0.3) rotate(-15deg); \n    filter: blur(10px);\n  }\n  50% { \n    opacity: 0.8; \n    transform: scale(1.2) rotate(5deg); \n    filter: blur(2px);\n  }\n  100% { \n    opacity: 1; \n    transform: scale(1) rotate(0deg); \n    filter: blur(0px);\n  }\n`;\n\nconst mintNumberGlow = keyframes`\n  0%, 100% { \n    box-shadow: 0 0 20px rgba(255, 176, 0, 0.6);\n    transform: scale(1);\n  }\n  50% { \n    box-shadow: 0 0 40px rgba(255, 176, 0, 0.9);\n    transform: scale(1.05);\n  }\n`;\n\nconst exclusivityPulse = keyframes`\n  0%, 100% { \n    opacity: 0.8;\n    transform: scale(1);\n  }\n  50% { \n    opacity: 1;\n    transform: scale(1.1);\n  }\n`;\n\nconst sparkleAnimation = keyframes`\n  0%, 100% { \n    opacity: 0;\n    transform: scale(0) rotate(0deg);\n  }\n  50% { \n    opacity: 1;\n    transform: scale(1) rotate(180deg);\n  }\n`;\n\nconst valueGlow = keyframes`\n  0%, 100% { \n    text-shadow: 0 0 10px rgba(255, 176, 0, 0.5);\n  }\n  50% { \n    text-shadow: 0 0 20px rgba(255, 176, 0, 0.8);\n  }\n`;\n\nconst Container = styled.div`\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background: rgba(18, 18, 18, 0.9);\n  backdrop-filter: blur(20px);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  z-index: 1000;\n  padding: 1rem;\n`;\n\nconst ModalCard = styled(GlassCard)`\n  padding: 2rem;\n  text-align: center;\n  animation: ${limitedEditionReveal} 0.8s ease-out;\n  max-width: 90vw;\n  width: 480px;\n  position: relative;\n  overflow: hidden;\n  \n  &::before {\n    content: '';\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    height: 4px;\n    background: ${props => props.exclusivityColor || '#FFB000'};\n    background: linear-gradient(90deg, \n      ${props => props.exclusivityColor || '#FFB000'} 0%, \n      ${props => props.exclusivityColor || '#FFB000'}80 50%, \n      ${props => props.exclusivityColor || '#FFB000'} 100%\n    );\n  }\n\n  /* Sparkle effects */\n  &::after {\n    content: '✨';\n    position: absolute;\n    top: 10%;\n    right: 10%;\n    font-size: 1.5rem;\n    animation: ${sparkleAnimation} 3s ease-in-out infinite;\n    animation-delay: 0.5s;\n  }\n`;\n\nconst ExclusivityBadge = styled.div`\n  position: absolute;\n  top: 1rem;\n  right: 1rem;\n  background: ${props => props.color || '#FFB000'};\n  color: #000;\n  padding: 0.5rem 1rem;\n  border-radius: 20px;\n  font-size: 0.8rem;\n  font-weight: 700;\n  text-transform: uppercase;\n  letter-spacing: 0.5px;\n  animation: ${exclusivityPulse} 2s ease-in-out infinite;\n  box-shadow: 0 4px 15px rgba(255, 176, 0, 0.3);\n  z-index: 2;\n`;\n\nconst MintNumberContainer = styled.div`\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  margin: 1.5rem 0;\n  gap: 1rem;\n  position: relative;\n`;\n\nconst MintNumberBadge = styled.div`\n  background: linear-gradient(135deg, #FFB000 0%, #FF9F1C 100%);\n  color: #000;\n  padding: 0.75rem 1.5rem;\n  border-radius: 25px;\n  font-size: 1.2rem;\n  font-weight: 700;\n  animation: ${mintNumberGlow} 3s ease-in-out infinite;\n  position: relative;\n  \n  &::before {\n    content: 'MINT #';\n    position: absolute;\n    top: -0.5rem;\n    left: 50%;\n    transform: translateX(-50%);\n    font-size: 0.7rem;\n    font-weight: 600;\n    color: rgba(0, 0, 0, 0.7);\n  }\n\n  &::after {\n    content: 'OF ${props => props.totalSupply || '100'}';\n    position: absolute;\n    bottom: -0.5rem;\n    left: 50%;\n    transform: translateX(-50%);\n    font-size: 0.6rem;\n    font-weight: 600;\n    color: rgba(0, 0, 0, 0.7);\n  }\n`;\n\nconst SupplyInfo = styled.div`\n  display: grid;\n  grid-template-columns: repeat(2, 1fr);\n  gap: 1rem;\n  background: rgba(255, 176, 0, 0.1);\n  padding: 1.5rem;\n  border-radius: 12px;\n  margin: 1.5rem 0;\n  border: 1px solid rgba(255, 176, 0, 0.2);\n  position: relative;\n`;\n\nconst SupplyItem = styled.div`\n  text-align: center;\n  \n  .label {\n    font-size: 0.8rem;\n    color: ${({ theme }) => theme.colors.text.secondary};\n    margin-bottom: 0.5rem;\n    text-transform: uppercase;\n    letter-spacing: 0.5px;\n  }\n  \n  .value {\n    font-size: 1.3rem;\n    font-weight: 700;\n    color: ${({ theme }) => theme.colors.text.primary};\n    animation: ${props => props.isHighlighted ? valueGlow : 'none'} 2s ease-in-out infinite;\n  }\n\n  .subtitle {\n    font-size: 0.7rem;\n    color: ${({ theme }) => theme.colors.text.secondary};\n    margin-top: 0.25rem;\n  }\n`;\n\nconst RewardImage = styled.div`\n  width: 140px;\n  height: 140px;\n  margin: 0 auto 1.5rem;\n  border-radius: 50%;\n  background: ${props => props.imageUrl ? `url(${props.imageUrl})` : 'linear-gradient(135deg, #FFB000 0%, #FF9F1C 100%)'};\n  background-size: cover;\n  background-position: center;\n  border: 4px solid ${props => props.exclusivityColor || '#FFB000'};\n  box-shadow: 0 8px 25px rgba(255, 176, 0, 0.3);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-size: 3rem;\n  position: relative;\n  \n  ${props => !props.imageUrl && `\n    &::after {\n      content: '🦋';\n      font-size: 3rem;\n    }\n  `}\n\n  /* Rarity ring effect */\n  &::before {\n    content: '';\n    position: absolute;\n    top: -8px;\n    left: -8px;\n    right: -8px;\n    bottom: -8px;\n    border-radius: 50%;\n    border: 2px solid ${props => props.exclusivityColor || '#FFB000'};\n    opacity: 0.6;\n    animation: ${exclusivityPulse} 3s ease-in-out infinite;\n  }\n`;\n\nconst RewardTitle = styled.h2`\n  font-family: ${({ theme }) => theme.typography.fontFamily.heading};\n  color: ${({ theme }) => theme.colors.text.primary};\n  font-size: 1.8rem;\n  margin-bottom: 0.5rem;\n  font-weight: 700;\n`;\n\nconst RewardDescription = styled.p`\n  color: ${({ theme }) => theme.colors.text.secondary};\n  font-size: 1rem;\n  line-height: 1.5;\n  margin-bottom: 1.5rem;\n`;\n\nconst WingsEarned = styled.div`\n  font-size: 1.6rem;\n  color: ${({ theme }) => theme.colors.accent.gold};\n  font-weight: 700;\n  margin-bottom: 1rem;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: 0.5rem;\n  animation: ${valueGlow} 2s ease-in-out infinite;\n  \n  &::before {\n    content: '🦋';\n    font-size: 1.4rem;\n  }\n\n  .bonus {\n    font-size: 0.9rem;\n    color: ${({ theme }) => theme.colors.text.secondary};\n    margin-left: 0.5rem;\n    font-weight: 400;\n  }\n`;\n\nconst CollectionValue = styled.div`\n  background: linear-gradient(135deg, rgba(255, 176, 0, 0.1) 0%, rgba(255, 159, 28, 0.1) 100%);\n  border: 1px solid rgba(255, 176, 0, 0.3);\n  border-radius: 12px;\n  padding: 1rem;\n  margin: 1.5rem 0;\n  text-align: center;\n`;\n\nconst ValueTitle = styled.h3`\n  font-size: 1rem;\n  color: ${({ theme }) => theme.colors.accent.gold};\n  margin-bottom: 0.5rem;\n  font-weight: 600;\n`;\n\nconst ValueDescription = styled.p`\n  font-size: 0.9rem;\n  color: ${({ theme }) => theme.colors.text.secondary};\n  line-height: 1.4;\n  margin: 0;\n`;\n\nconst SocialSharing = styled.div`\n  background: rgba(127, 63, 191, 0.1);\n  border: 1px solid rgba(127, 63, 191, 0.3);\n  border-radius: 12px;\n  padding: 1rem;\n  margin: 1.5rem 0;\n  text-align: center;\n`;\n\nconst SocialTitle = styled.h3`\n  font-size: 1rem;\n  color: #7F3FBF;\n  margin-bottom: 0.5rem;\n  font-weight: 600;\n`;\n\nconst SocialDescription = styled.p`\n  font-size: 0.9rem;\n  color: ${({ theme }) => theme.colors.text.secondary};\n  line-height: 1.4;\n  margin-bottom: 1rem;\n`;\n\nconst ShareButton = styled.button`\n  background: linear-gradient(135deg, #7F3FBF 0%, #5B21B6 100%);\n  border: none;\n  color: white;\n  padding: 0.75rem 1.5rem;\n  font-size: 0.9rem;\n  font-weight: 600;\n  border-radius: 8px;\n  cursor: pointer;\n  transition: all 0.3s ease;\n  margin: 0 0.5rem;\n  \n  &:hover {\n    transform: translateY(-2px);\n    box-shadow: 0 4px 15px rgba(127, 63, 191, 0.4);\n  }\n\n  &:disabled {\n    opacity: 0.6;\n    cursor: not-allowed;\n    transform: none;\n  }\n`;\n\nconst ClaimedAt = styled.div`\n  font-size: 0.9rem;\n  color: ${({ theme }) => theme.colors.text.secondary};\n  margin-bottom: 1.5rem;\n  font-style: italic;\n`;\n\nconst ButtonContainer = styled.div`\n  display: flex;\n  flex-direction: column;\n  gap: 1rem;\n  margin-top: 2rem;\n`;\n\nconst ViewInClosetButton = styled(GlowButton)`\n  background: linear-gradient(135deg, #7F3FBF 0%, #5B21B6 100%);\n  border: none;\n  color: white;\n  padding: 1rem 2rem;\n  font-size: 1rem;\n  font-weight: 600;\n  border-radius: 12px;\n  cursor: pointer;\n  transition: all 0.3s ease;\n  \n  &:hover {\n    transform: translateY(-2px);\n    box-shadow: 0 8px 25px rgba(127, 63, 191, 0.4);\n  }\n`;\n\nconst CloseButton = styled.button`\n  background: transparent;\n  border: 2px solid ${({ theme }) => theme.colors.text.secondary};\n  color: ${({ theme }) => theme.colors.text.secondary};\n  padding: 0.75rem 1.5rem;\n  font-size: 1rem;\n  border-radius: 12px;\n  cursor: pointer;\n  transition: all 0.3s ease;\n  \n  &:hover {\n    border-color: ${({ theme }) => theme.colors.text.primary};\n    color: ${({ theme }) => theme.colors.text.primary};\n  }\n`;\n\nconst LimitedEditionRewardModal = ({ \n  reward, \n  claimResult, \n  onClose, \n  onShowInCloset \n}) => {\n  const [shareAttempted, setShareAttempted] = useState(false);\n\n  if (!reward) return null;\n\n  const {\n    name,\n    description,\n    limitedEdition,\n    images\n  } = reward;\n\n  const {\n    mintNumber,\n    claimedAt,\n    totalWingsValue\n  } = claimResult || {};\n\n  const {\n    totalSupply,\n    claimedCount,\n    availableCount,\n    claimPercentage\n  } = claimResult?.availability || {};\n\n  // Get exclusivity info\n  const exclusivityLevel = limitedEdition?.exclusivityLevel;\n  const exclusivityColor = exclusivityLevel === 'mythic' ? '#10B981' : \n                          exclusivityLevel === 'legendary' ? '#7F3FBF' : '#FFB000';\n\n  // Get primary image\n  const primaryImage = images?.[0]?.src || null;\n\n  // Calculate collection value\n  const baseWingsValue = limitedEdition?.baseWings || 100;\n  const bonusWings = limitedEdition?.bonusWings || 0;\n\n  // Format claimed date\n  const formatClaimedDate = (dateString) => {\n    if (!dateString) return '';\n    const date = new Date(dateString);\n    return date.toLocaleDateString('en-US', {\n      year: 'numeric',\n      month: 'long',\n      day: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit'\n    });\n  };\n\n  // Handle social sharing\n  const handleShare = async () => {\n    const shareText = `🦋 Just claimed ${name} - Mint #${mintNumber} of ${totalSupply}! Exclusive limited edition from Monarch Passport. #PapillonLabs #LimitedEdition`;\n    const shareUrl = window.location.origin;\n\n    if (navigator.share) {\n      try {\n        await navigator.share({\n          title: 'Monarch Passport Limited Edition',\n          text: shareText,\n          url: shareUrl\n        });\n      } catch (error) {\n        console.log('Share cancelled or failed');\n      }\n    } else {\n      // Fallback to clipboard\n      try {\n        await navigator.clipboard.writeText(`${shareText}\\n${shareUrl}`);\n        setShareAttempted(true);\n        setTimeout(() => setShareAttempted(false), 3000);\n      } catch (error) {\n        console.log('Clipboard not available');\n      }\n    }\n  };\n\n  // Get collection value message\n  const getCollectionValueMessage = () => {\n    const percentage = claimPercentage || 0;\n    if (percentage < 25) {\n      return \"Early adopter! This item is part of an exclusive collection that's just getting started.\";\n    } else if (percentage < 50) {\n      return \"Growing collection! This limited edition is becoming increasingly rare as more collectors join.\";\n    } else if (percentage < 75) {\n      return \"Rare find! Over half the supply has been claimed, making this item highly exclusive.\";\n    } else {\n      return \"Ultra rare! Nearly all items have been claimed. You're among the final collectors.\";\n    }\n  };\n\n  return (\n    <Container onClick={onClose} role=\"dialog\" aria-modal=\"true\" aria-labelledby=\"reward-title\">\n      <ModalCard \n        onClick={(e) => e.stopPropagation()}\n        exclusivityColor={exclusivityColor}\n      >\n        {/* Exclusivity Badge */}\n        <ExclusivityBadge color={exclusivityColor} aria-label={`${exclusivityLevel} rarity level`}>\n          {exclusivityLevel?.replace('_', ' ').toUpperCase() || 'LIMITED'}\n        </ExclusivityBadge>\n\n        {/* Reward Image */}\n        <RewardImage \n          imageUrl={primaryImage}\n          exclusivityColor={exclusivityColor}\n          aria-label={`${name} product image`}\n        />\n\n        {/* Mint Number */}\n        {mintNumber && (\n          <MintNumberContainer>\n            <MintNumberBadge totalSupply={totalSupply} aria-label={`Mint number ${mintNumber} of ${totalSupply}`}>\n              {mintNumber}\n            </MintNumberBadge>\n          </MintNumberContainer>\n        )}\n\n        {/* Reward Title */}\n        <RewardTitle id=\"reward-title\">{name}</RewardTitle>\n\n        {/* Reward Description */}\n        <RewardDescription>{description}</RewardDescription>\n\n        {/* Supply Information */}\n        {totalSupply && (\n          <SupplyInfo role=\"region\" aria-label=\"Supply information\">\n            <SupplyItem isHighlighted={true}>\n              <div className=\"label\">Total Supply</div>\n              <div className=\"value\">{totalSupply}</div>\n              <div className=\"subtitle\">Limited Edition</div>\n            </SupplyItem>\n            <SupplyItem>\n              <div className=\"label\">Claimed</div>\n              <div className=\"value\">{claimedCount || 0}</div>\n              <div className=\"subtitle\">Collectors</div>\n            </SupplyItem>\n            <SupplyItem>\n              <div className=\"label\">Available</div>\n              <div className=\"value\">{availableCount || 0}</div>\n              <div className=\"subtitle\">Remaining</div>\n            </SupplyItem>\n            <SupplyItem isHighlighted={claimPercentage > 75}>\n              <div className=\"label\">Progress</div>\n              <div className=\"value\">{claimPercentage?.toFixed(1) || 0}%</div>\n              <div className=\"subtitle\">Claimed</div>\n            </SupplyItem>\n          </SupplyInfo>\n        )}\n\n        {/* WINGS Earned */}\n        {totalWingsValue && (\n                      <WingsEarned aria-label={`Earned ${totalWingsValue} WNGS`}>\n                            +{totalWingsValue} WNGS\n            {bonusWings > 0 && (\n              <span className=\"bonus\">(+{bonusWings} bonus)</span>\n            )}\n          </WingsEarned>\n        )}\n\n        {/* Collection Value */}\n        <CollectionValue role=\"region\" aria-label=\"Collection value information\">\n          <ValueTitle>Collection Value</ValueTitle>\n          <ValueDescription>\n            {getCollectionValueMessage()}\n          </ValueDescription>\n        </CollectionValue>\n\n        {/* Social Sharing */}\n        <SocialSharing role=\"region\" aria-label=\"Social sharing options\">\n          <SocialTitle>Share Your Achievement</SocialTitle>\n          <SocialDescription>\n            Show off your exclusive limited edition item to the Monarch community!\n          </SocialDescription>\n          <ShareButton \n            onClick={handleShare}\n            disabled={shareAttempted}\n            aria-label=\"Share limited edition claim\"\n          >\n            {shareAttempted ? 'Copied!' : 'Share'}\n          </ShareButton>\n        </SocialSharing>\n\n        {/* Claimed Date */}\n        {claimedAt && (\n          <ClaimedAt aria-label={`Claimed on ${formatClaimedDate(claimedAt)}`}>\n            Claimed on {formatClaimedDate(claimedAt)}\n          </ClaimedAt>\n        )}\n\n        {/* Buttons */}\n        <ButtonContainer>\n          {onShowInCloset && (\n            <ViewInClosetButton onClick={onShowInCloset} aria-label=\"View item in closet\">\n              View in Closet\n            </ViewInClosetButton>\n          )}\n          <CloseButton onClick={onClose} aria-label=\"Close modal\">\n            Close\n          </CloseButton>\n        </ButtonContainer>\n      </ModalCard>\n    </Container>\n  );\n};\n\nexport default LimitedEditionRewardModal; ","/**\n * Limited Edition QR Processor\n * PapillonLabs Monarch Passport MVP\n * \n * This module provides utilities for processing limited edition QR codes\n * with enhanced validation, atomic claiming, and proper error handling.\n */\n\nimport { createClient } from '@supabase/supabase-js';\nimport MONARCH_REWARDS, { RewardUtils } from '../config/monarchRewards';\n\nconst supabase = createClient(\n  process.env.REACT_APP_SUPABASE_URL,\n  process.env.REACT_APP_SUPABASE_ANON_KEY\n);\n\n/**\n * Check limited edition availability before claiming\n * @param {string} rewardId - The reward ID to check\n * @returns {Promise<Object>} Availability status and details\n */\nexport const checkLimitedEditionAvailability = async (rewardId) => {\n  try {\n    console.log(`🔍 Checking limited edition availability for: ${rewardId}`);\n\n    // Get static reward configuration\n    const staticReward = RewardUtils.getRewardById(rewardId);\n    if (!staticReward) {\n      return {\n        available: false,\n        error: 'Reward not found in configuration',\n        reason: 'INVALID_REWARD'\n      };\n    }\n\n    // Check if it's a limited edition\n    if (!staticReward.limitedEdition) {\n      return {\n        available: true,\n        isLimitedEdition: false,\n        reward: staticReward,\n        reason: 'REGULAR_REWARD'\n      };\n    }\n\n    // Get limited edition status from database\n    const { data, error } = await supabase\n      .rpc('get_limited_edition_status', { p_reward_id: rewardId });\n\n    if (error) {\n      console.error('Error checking limited edition status:', error);\n      return {\n        available: false,\n        error: 'Failed to check limited edition status',\n        reason: 'DATABASE_ERROR'\n      };\n    }\n\n    if (!data || data.length === 0) {\n      return {\n        available: false,\n        error: 'Limited edition not found in database',\n        reason: 'NOT_INITIALIZED'\n      };\n    }\n\n    const status = data[0];\n    const isAvailable = status.available_count > 0 && status.is_active;\n\n    return {\n      available: isAvailable,\n      isLimitedEdition: true,\n      reward: staticReward,\n      status: {\n        totalSupply: status.total_supply,\n        claimedCount: status.claimed_count,\n        availableCount: status.available_count,\n        claimPercentage: status.claim_percentage,\n        isActive: status.is_active,\n        startDate: status.start_date,\n        endDate: status.end_date,\n        userHasClaimed: status.user_has_claimed,\n        userMintNumber: status.user_mint_number\n      },\n      reason: isAvailable ? 'AVAILABLE' : 'EXHAUSTED'\n    };\n  } catch (error) {\n    console.error('Error in checkLimitedEditionAvailability:', error);\n    return {\n      available: false,\n      error: error.message,\n      reason: 'UNKNOWN_ERROR'\n    };\n  }\n};\n\n/**\n * Claim a limited edition item with atomic operations\n * @param {string} rewardId - The reward ID to claim\n * @param {string} userId - The user ID claiming the reward\n * @param {string} qrScanLocation - Optional QR scan location\n * @returns {Promise<Object>} Claim result with mint number and details\n */\nexport const claimLimitedEditionItem = async (rewardId, userId, qrScanLocation = null) => {\n  try {\n    console.log(`🎯 Claiming limited edition: ${rewardId} for user: ${userId}`);\n\n    // Check availability first\n    const availability = await checkLimitedEditionAvailability(rewardId);\n    if (!availability.available) {\n      return {\n        success: false,\n        error: availability.error,\n        reason: availability.reason\n      };\n    }\n\n    // Use the atomic claim function from the database\n    const { data, error } = await supabase\n      .rpc('claim_limited_edition_item', {\n        p_reward_id: rewardId,\n        p_user_id: userId,\n        p_qr_scan_location: qrScanLocation\n      });\n\n    if (error) {\n      console.error('Error claiming limited edition:', error);\n      return {\n        success: false,\n        error: error.message,\n        reason: 'CLAIM_FAILED'\n      };\n    }\n\n    if (!data || data.length === 0) {\n      return {\n        success: false,\n        error: 'No response from claim function',\n        reason: 'NO_RESPONSE'\n      };\n    }\n\n    const result = data[0];\n    \n    if (!result.success) {\n      return {\n        success: false,\n        error: result.message,\n        reason: 'CLAIM_REJECTED'\n      };\n    }\n\n    // Get the static reward data for additional details\n    const staticReward = RewardUtils.getRewardById(rewardId);\n    const totalWingsValue = RewardUtils.getTotalWingsValue(rewardId);\n\n    return {\n      success: true,\n      mintNumber: result.mint_number,\n      claimedAt: result.claimed_at,\n      message: result.message,\n      reward: staticReward,\n      totalWingsValue,\n      limitedEdition: staticReward?.limitedEdition,\n      qrScanLocation\n    };\n  } catch (error) {\n    console.error('Error in claimLimitedEditionItem:', error);\n    return {\n      success: false,\n      error: error.message,\n      reason: 'UNKNOWN_ERROR'\n    };\n  }\n};\n\n/**\n * Process limited edition QR code with enhanced validation\n * @param {Object} qrData - QR code data object\n * @param {string} userId - The user ID processing the QR\n * @param {string} qrScanLocation - Optional QR scan location\n * @returns {Promise<Object>} Processing result\n */\nexport const processLimitedEditionQR = async (qrData, userId, qrScanLocation = null) => {\n  try {\n    console.log('🔄 Processing limited edition QR code:', qrData);\n\n    // Validate QR data structure\n    if (!qrData || !qrData.rewardId) {\n      return {\n        success: false,\n        error: 'Invalid QR code data',\n        reason: 'INVALID_QR_DATA'\n      };\n    }\n\n    const rewardId = qrData.rewardId;\n\n    // Check if reward exists in static configuration\n    const staticReward = RewardUtils.getRewardById(rewardId);\n    if (!staticReward) {\n      return {\n        success: false,\n        error: 'Reward not found in configuration',\n        reason: 'REWARD_NOT_FOUND'\n      };\n    }\n\n    // Check if user is authenticated\n    if (!userId) {\n      return {\n        success: false,\n        error: 'User not authenticated',\n        reason: 'NOT_AUTHENTICATED'\n      };\n    }\n\n    // Check if user already claimed this reward\n    const { data: existingClaim } = await supabase\n      .from('limited_edition_claims')\n      .select('id, mint_number')\n      .eq('user_id', userId)\n      .eq('limited_edition_id', \n        (await supabase\n          .from('limited_edition_items')\n          .select('id')\n          .eq('reward_id', rewardId)\n          .single()\n        ).data?.id\n      )\n      .maybeSingle();\n\n    if (existingClaim) {\n      return {\n        success: false,\n        error: 'You have already claimed this limited edition item',\n        reason: 'ALREADY_CLAIMED',\n        existingClaim: {\n          mintNumber: existingClaim.mint_number\n        }\n      };\n    }\n\n    // Check availability\n    const availability = await checkLimitedEditionAvailability(rewardId);\n    if (!availability.available) {\n      return {\n        success: false,\n        error: availability.error,\n        reason: availability.reason,\n        status: availability.status\n      };\n    }\n\n    // Claim the limited edition item\n    const claimResult = await claimLimitedEditionItem(rewardId, userId, qrScanLocation);\n    \n    if (!claimResult.success) {\n      return claimResult;\n    }\n\n    // Log activity for limited edition claim\n    try {\n      await supabase\n        .from('user_activity')\n        .insert({\n          user_id: userId,\n          activity_type: 'limited_edition_claim',\n          activity_title: `Limited Edition: ${staticReward.name}`,\n          activity_description: `Claimed mint #${claimResult.mintNumber} • ${claimResult.totalWingsValue} WINGS earned`,\n          wings_earned: claimResult.totalWingsValue,\n          reward_id: rewardId,\n          metadata: {\n            mintNumber: claimResult.mintNumber,\n            limitedEditionId: rewardId,\n            totalSupply: staticReward.limitedEdition.totalSupply,\n            exclusivityLevel: staticReward.limitedEdition.exclusivityLevel,\n            qrScanLocation\n          }\n        });\n    } catch (activityError) {\n      console.warn('Failed to log limited edition activity:', activityError);\n    }\n\n    return {\n      success: true,\n      reward: staticReward,\n      claimResult,\n      availability: availability.status\n    };\n  } catch (error) {\n    console.error('Error in processLimitedEditionQR:', error);\n    return {\n      success: false,\n      error: error.message,\n      reason: 'PROCESSING_ERROR'\n    };\n  }\n};\n\n/**\n * Get enhanced reward modal data for limited edition items\n * @param {string} rewardId - The reward ID\n * @param {Object} claimResult - The claim result from processLimitedEditionQR\n * @returns {Object} Enhanced modal data\n */\nexport const getLimitedEditionModalData = (rewardId, claimResult = null) => {\n  try {\n    const staticReward = RewardUtils.getRewardById(rewardId);\n    if (!staticReward) {\n      return null;\n    }\n\n    const isLimitedEdition = !!staticReward.limitedEdition;\n    const exclusivityLevel = staticReward.limitedEdition?.exclusivityLevel;\n    const exclusivityInfo = RewardUtils.getExclusivityLevel(exclusivityLevel);\n\n    return {\n      reward: staticReward,\n      isLimitedEdition,\n      exclusivityInfo,\n      claimResult,\n      modalType: isLimitedEdition ? 'limited_edition' : 'regular',\n      primaryImage: RewardUtils.getPrimaryImage(rewardId),\n      shopifyUrl: RewardUtils.getShopifyUrl(rewardId),\n      totalWingsValue: RewardUtils.getTotalWingsValue(rewardId),\n      colors: RewardUtils.getMonarchColors()\n    };\n  } catch (error) {\n    console.error('Error in getLimitedEditionModalData:', error);\n    return null;\n  }\n};\n\n/**\n * Validate QR code payload for limited edition compatibility\n * @param {string} qrText - Raw QR code text\n * @returns {Object} Validation result\n */\nexport const validateLimitedEditionQR = (qrText) => {\n  try {\n    const payload = JSON.parse(qrText);\n    \n    // Basic validation\n    if (payload.type !== 'monarch_reward') {\n      return {\n        valid: false,\n        error: 'Invalid QR code type',\n        reason: 'INVALID_TYPE'\n      };\n    }\n\n    if (!payload.rewardId) {\n      return {\n        valid: false,\n        error: 'Missing reward ID',\n        reason: 'MISSING_REWARD_ID'\n      };\n    }\n\n    // Check if reward exists in static configuration\n    const staticReward = RewardUtils.getRewardById(payload.rewardId);\n    if (!staticReward) {\n      return {\n        valid: false,\n        error: 'Reward not found in configuration',\n        reason: 'REWARD_NOT_FOUND'\n      };\n    }\n\n    // Check if reward is active\n    if (!staticReward.isActive) {\n      return {\n        valid: false,\n        error: 'Reward is not currently available',\n        reason: 'REWARD_INACTIVE'\n      };\n    }\n\n    // Check timestamp if present (prevent old QR codes)\n    if (payload.timestamp && payload.timestamp < Date.now() - 86400000) { // 24 hours\n      return {\n        valid: false,\n        error: 'QR code has expired',\n        reason: 'EXPIRED'\n      };\n    }\n\n    return {\n      valid: true,\n      payload,\n      reward: staticReward,\n      isLimitedEdition: !!staticReward.limitedEdition\n    };\n  } catch (error) {\n    console.error('Error validating limited edition QR:', error);\n    return {\n      valid: false,\n      error: 'Invalid QR code format',\n      reason: 'INVALID_FORMAT'\n    };\n  }\n};\n\n/**\n * Get limited edition analytics for a specific reward\n * @param {string} rewardId - The reward ID\n * @returns {Promise<Object>} Analytics data\n */\nexport const getLimitedEditionAnalytics = async (rewardId) => {\n  try {\n    const { data, error } = await supabase\n      .from('limited_edition_analytics')\n      .select('*')\n      .eq('reward_id', rewardId)\n      .single();\n\n    if (error) {\n      console.error('Error fetching limited edition analytics:', error);\n      return null;\n    }\n\n    return data;\n  } catch (error) {\n    console.error('Error in getLimitedEditionAnalytics:', error);\n    return null;\n  }\n};\n\n// Export utility functions\nexport const LimitedEditionQRProcessor = {\n  checkLimitedEditionAvailability,\n  claimLimitedEditionItem,\n  processLimitedEditionQR,\n  getLimitedEditionModalData,\n  validateLimitedEditionQR,\n  getLimitedEditionAnalytics\n};\n\nexport default LimitedEditionQRProcessor; ","import React, { useState, useEffect, useRef, useCallback } from 'react';\nimport styled, { keyframes } from 'styled-components';\n// Dynamic import for html5-qrcode to prevent chunk loading issues\n// import { Html5Qrcode, Html5QrcodeScanType } from 'html5-qrcode';\nimport { useNavigate } from 'react-router-dom';\nimport { createClient } from '@supabase/supabase-js';\nimport { useAuth } from '../hooks/useAuth';\nimport { useStamps } from '../hooks/useStamps';\nimport { useReferrals } from '../hooks/useReferrals';\nimport { useMonarchRewards } from '../hooks/useMonarchRewards';\nimport { enhancedSecurity } from '../utils/enhancedSecurity';\n// Circular QR imports commented out for now\n// import { detectCircularQR } from '../utils/circularQRDetection';\n// import { validateSecureCircularQR, decryptCircularQR } from '../utils/secureCircularQR';\nimport GlassCard from '../components/GlassCard';\nimport GlowButton from '../components/GlowButton';\nimport LimitedEditionRewardModal from '../components/LimitedEditionRewardModal';\nimport { \n  validateLimitedEditionQR, \n  processLimitedEditionQR,\n  getLimitedEditionModalData \n} from '../utils/limitedEditionQRProcessor';\nimport NavBar from '../components/NavBar';\n\n// Supabase client\nconst supabase = createClient(\n  process.env.REACT_APP_SUPABASE_URL,\n  process.env.REACT_APP_SUPABASE_ANON_KEY\n);\n\nconst rewardReveal = keyframes`\n  0% { opacity: 0; transform: scale(0.5) rotate(-10deg); }\n  50% { opacity: 1; transform: scale(1.1) rotate(5deg); }\n  100% { opacity: 1; transform: scale(1) rotate(0deg); }\n`;\n\nconst Container = styled.div`\n  min-height: 100vh;\n  background: ${({ theme }) => theme.colors.background};\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  padding: 2rem 1rem 6rem 1rem;\n`;\n\nconst ScannerCard = styled(GlassCard)`\n  padding: 2rem;\n  width: 100%;\n  max-width: 400px;\n  text-align: center;\n`;\n\nconst LoadingOverlay = styled.div`\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background: rgba(18, 18, 18, 0.3);\n  backdrop-filter: blur(20px);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  z-index: 1000;\n`;\n\nconst RewardModal = styled(GlassCard)`\n  padding: 3rem 2rem;\n  text-align: center;\n  animation: ${rewardReveal} 0.6s ease-out;\n  max-width: 90vw;\n  width: 400px;\n`;\n\nconst RewardIcon = styled.div`\n  font-size: 4rem;\n  margin-bottom: 1rem;\n`;\n\nconst RewardTitle = styled.h2`\n  font-family: ${({ theme }) => theme.typography.fontFamily.heading};\n  color: ${({ theme }) => theme.colors.text.primary};\n  font-size: 1.5rem;\n  margin-bottom: 1rem;\n`;\n\nconst WingsEarned = styled.div`\n  font-size: 1.2rem;\n  color: ${({ theme }) => theme.colors.accent.gold};\n  font-weight: 600;\n  margin-bottom: 2rem;\n`;\n\nconst ErrorCard = styled(GlassCard)`\n  padding: 2rem;\n  text-align: center;\n  background: rgba(231, 76, 60, 0.1);\n  border: 1px solid rgba(231, 76, 60, 0.3);\n`;\n\nconst LoadingProgressBar = styled.div`\n  width: 100%;\n  height: 4px;\n  background: rgba(255, 176, 0, 0.2);\n  border-radius: 2px;\n  overflow: hidden;\n  margin: 1rem 0;\n`;\n\nconst LoadingProgressFill = styled.div`\n  height: 100%;\n  background: linear-gradient(90deg, #FFB000, #FFD700);\n  border-radius: 2px;\n  transition: width 0.3s ease;\n  width: ${props => props.progress}%;\n`;\n\nconst LoadingSpinner = styled.div`\n  width: 40px;\n  height: 40px;\n  border: 3px solid rgba(255, 176, 0, 0.2);\n  border-top: 3px solid #FFB000;\n  border-radius: 50%;\n  animation: spin 1s linear infinite;\n  margin: 0 auto 1rem;\n  \n  @keyframes spin {\n    0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n  }\n`;\n\nconst StateTransition = styled.div`\n  opacity: ${props => props.visible ? 1 : 0};\n  transform: translateY(${props => props.visible ? 0 : '20px'});\n  transition: all 0.3s ease-in-out;\n`;\n\nconst ConnectionIndicator = styled.div`\n  position: absolute;\n  top: 1rem;\n  right: 1rem;\n  padding: 0.5rem 1rem;\n  background: rgba(18, 18, 18, 0.8);\n  border-radius: 20px;\n  font-size: 0.8rem;\n  color: ${props => props.quality === 'good' ? '#4CAF50' : props.quality === 'slow' ? '#FF9800' : '#f44336'};\n  border: 1px solid ${props => props.quality === 'good' ? '#4CAF50' : props.quality === 'slow' ? '#FF9800' : '#f44336'};\n  backdrop-filter: blur(10px);\n  z-index: 10;\n`;\n\nconst ButtonContainer = styled.div`\n  display: flex;\n  flex-direction: column;\n  gap: 1rem;\n  margin-top: 2rem;\n`;\n\nconst ClaimButton = styled.button`\n  background: ${props => props.claimed \n    ? 'linear-gradient(135deg, #FFB000 0%, #FF9F1C 100%)'\n    : 'linear-gradient(135deg, #4C1C8C 0%, #7F3FBF 50%, #9D4EDD 100%)'\n  };\n  color: ${props => props.claimed ? '#000' : '#FAFAFA'};\n  border: 2px solid #FFB000;\n  border-radius: 12px;\n  font-size: 1.1rem;\n  font-weight: 600;\n  padding: 0.75rem 2rem;\n  cursor: pointer;\n  transition: all 0.3s ease;\n  \n  &:hover {\n    transform: translateY(-2px);\n  }\n`;\n\nconst SecondaryButton = styled.button`\n  background: transparent;\n  color: #aaa;\n  border: 1px solid rgba(255, 255, 255, 0.2);\n  border-radius: 12px;\n  font-size: 1rem;\n  font-weight: 500;\n  padding: 0.6rem 1.5rem;\n  cursor: pointer;\n  transition: all 0.2s ease;\n  \n  &:hover {\n    background: rgba(255, 255, 255, 0.1);\n    color: #fff;\n  }\n`;\n\nconst QuestUpdateBanner = styled.div`\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  background: linear-gradient(135deg, #10B981 0%, #059669 100%);\n  color: white;\n  padding: 0.5rem;\n  font-size: 0.8rem;\n  font-weight: 600;\n  text-align: center;\n  z-index: 10;\n`;\n\nconst CheckMark = styled.div`\n  width: 80px;\n  height: 80px;\n  border-radius: 50%;\n  background: linear-gradient(135deg, #10B981 0%, #059669 100%);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  margin: 0 auto 1.5rem;\n  font-size: 2.5rem;\n  color: white;\n`;\n\nconst EnhancedRewardModal = ({ reward, onClose, onShowInCloset, user }) => {\n  const [claimState, setClaimState] = useState('unclaimed');\n  const [questUpdate, setQuestUpdate] = useState(null);\n  const [showQuestUpdate, setShowQuestUpdate] = useState(false);\n\n  const checkQuestProgress = async (userId, rewardCategory) => {\n    try {\n      const { data: questData } = await supabase\n        .from('user_quest_progress')\n        .select('*')\n        .eq('user_id', userId)\n        .eq('status', 'active');\n\n      if (!questData || questData.length === 0) return null;\n\n      const scanQuest = questData.find(q => \n        q.quest_type === 'scan_items' || \n        q.quest_type === 'scan_physical_items' ||\n        (q.quest_type === 'scan_category' && q.category === rewardCategory)\n      );\n\n      if (scanQuest) {\n        const newProgress = (scanQuest.current_progress || 0) + 1;\n        const isCompleted = newProgress >= scanQuest.target_value;\n\n        await supabase\n          .from('user_quest_progress')\n          .update({\n            current_progress: newProgress,\n            status: isCompleted ? 'completed' : 'active',\n            completed_at: isCompleted ? new Date().toISOString() : null\n          })\n          .eq('id', scanQuest.id);\n\n        return {\n          questName: scanQuest.quest_title || 'Scan 10 Papillon Items',\n          oldProgress: scanQuest.current_progress || 0,\n          newProgress,\n          total: scanQuest.target_value || 10,\n          completed: isCompleted\n        };\n      }\n\n      return null;\n    } catch (error) {\n      console.warn('Failed to check quest progress:', error);\n      return null;\n    }\n  };\n\n  const handleClaim = async () => {\n    if (!reward || !user) return;\n    setClaimState('claiming');\n    \n    try {\n      await new Promise(resolve => setTimeout(resolve, 1500));\n      \n      const questProgress = await checkQuestProgress(user.id, reward.category);\n      if (questProgress) {\n        setQuestUpdate(questProgress);\n        setShowQuestUpdate(true);\n        setTimeout(() => setShowQuestUpdate(false), 4000);\n      }\n      \n      setClaimState('claimed');\n    } catch (error) {\n      console.error('Claim processing failed:', error);\n      setClaimState('unclaimed');\n    }\n  };\n\n  const getItemIcon = (category) => {\n    const icons = {\n      jackets: '🧥', tops: '👕', bottoms: '👖', headwear: '🧢',\n      accessories: '⛓️', footwear: '👟', themes: '🎨'\n    };\n    return icons[category] || '🎁';\n  };\n\n  if (!reward) return null;\n\n  return (\n    <LoadingOverlay>\n      <RewardModal>\n        {showQuestUpdate && questUpdate && (\n          <QuestUpdateBanner>\n            ⚡ Quest Progress: {questUpdate.questName} ({questUpdate.newProgress}/{questUpdate.total})\n            {questUpdate.completed && ' - COMPLETED! 🎉'}\n          </QuestUpdateBanner>\n        )}\n        \n        {claimState === 'unclaimed' && (\n          <>\n            <RewardIcon>{getItemIcon(reward.category)}</RewardIcon>\n            <RewardTitle>Reward Found!</RewardTitle>\n            <h3 style={{ color: '#fff', marginBottom: '0.5rem' }}>{reward.name}</h3>\n            <p style={{ color: '#aaa', marginBottom: '1rem' }}>\n              {reward.rarity} • #{reward.mintNumber}\n            </p>\n            {reward.wingsEarned > 0 && (\n                              <WingsEarned>+{reward.wingsEarned} WNGS 🦋</WingsEarned>\n            )}\n            <ButtonContainer>\n              <ClaimButton onClick={handleClaim}>🎁 Claim Reward</ClaimButton>\n              <SecondaryButton onClick={onClose}>Close</SecondaryButton>\n            </ButtonContainer>\n          </>\n        )}\n        \n        {claimState === 'claiming' && (\n          <>\n            <div style={{ fontSize: '3rem', marginBottom: '1rem' }}>⏳</div>\n            <RewardTitle>Processing your reward...</RewardTitle>\n            <p style={{ color: '#aaa' }}>Adding to closet and updating progress</p>\n          </>\n        )}\n        \n        {claimState === 'claimed' && (\n          <>\n            <CheckMark>✓</CheckMark>\n            <RewardTitle>Reward Claimed!</RewardTitle>\n            <h3 style={{ color: '#fff', marginBottom: '0.5rem' }}>{reward.name}</h3>\n            <p style={{ color: '#10B981', marginBottom: '1rem' }}>\n              Successfully added to your closet\n            </p>\n            {reward.wingsEarned > 0 && (\n              <p style={{ color: '#FFB000', marginBottom: '2rem' }}>\n                +{reward.wingsEarned} WNGS earned!\n              </p>\n            )}\n            <ButtonContainer>\n              <ClaimButton claimed={true} onClick={onShowInCloset}>\n                👕 Show in Closet\n              </ClaimButton>\n              <SecondaryButton onClick={onClose}>\n                Continue Scanning\n              </SecondaryButton>\n            </ButtonContainer>\n          </>\n        )}\n      </RewardModal>\n    </LoadingOverlay>\n  );\n};\n\nconst ScanScreen = () => {\n  const navigate = useNavigate();\n  const { user } = useAuth();\n  const { awardQRStamp, awardFirstItemStamp, awardStyleStamp, hasStamp } = useStamps();\n  const { completeReferral } = useReferrals();\n  const { claimReward: claimMonarchReward } = useMonarchRewards();\n  const [isScanning, setIsScanning] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const [cameraInitialized, setCameraInitialized] = useState(false);\n  const [cameraInitializing, setCameraInitializing] = useState(false);\n  const [reward, setReward] = useState(null);\n  const [error, setError] = useState(null);\n  const [cameraError, setCameraError] = useState(null);\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [limitedEditionResult, setLimitedEditionResult] = useState(null);\n  const [showLimitedEditionModal, setShowLimitedEditionModal] = useState(false);\n  const [qrLibraryLoaded, setQrLibraryLoaded] = useState(false);\n  const [qrLibraryError, setQrLibraryError] = useState(null);\n  const [loadingProgress, setLoadingProgress] = useState(0);\n  const [retryCount, setRetryCount] = useState(0);\n  const [connectionQuality, setConnectionQuality] = useState('unknown');\n  // Removed showPermissionRequest and debugInfo states for cleaner flow\n  const qrCodeScannerRef = useRef(null);\n  const qrLibraryRef = useRef(null);\n  const scannerElementId = \"qr-reader\";\n\n  // Check connection quality\n  const checkConnectionQuality = useCallback(() => {\n    if ('connection' in navigator) {\n      const connection = navigator.connection;\n      if (connection.effectiveType === '4g') {\n        setConnectionQuality('good');\n      } else if (connection.effectiveType === '3g' || connection.effectiveType === '2g') {\n        setConnectionQuality('slow');\n      } else {\n        setConnectionQuality('poor');\n      }\n    } else {\n      setConnectionQuality('unknown');\n    }\n  }, []);\n\n  // Dynamic import of html5-qrcode library with progress tracking and timeout\n  const loadQRLibrary = useCallback(async () => {\n    try {\n      setQrLibraryError(null);\n      setQrLibraryLoaded(false);\n      setLoadingProgress(0);\n      \n      // Check connection quality\n      checkConnectionQuality();\n      \n      // Increment retry count\n      setRetryCount(prev => prev + 1);\n      \n      // Limit retries to 3 attempts\n      if (retryCount >= 3) {\n        throw new Error('Max retries exceeded');\n      }\n      \n      // Simulate loading progress for better UX\n      const progressInterval = setInterval(() => {\n        setLoadingProgress(prev => Math.min(prev + 10, 80));\n      }, 100);\n      \n      // Add a small delay to prevent rapid retries\n      await new Promise(resolve => setTimeout(resolve, 100));\n      \n      // Add timeout for slow connections (15 seconds)\n      const timeoutPromise = new Promise((_, reject) => {\n        setTimeout(() => reject(new Error('Loading timeout')), 15000);\n      });\n      \n      const importPromise = import('html5-qrcode');\n      \n      const { Html5Qrcode, Html5QrcodeScanType } = await Promise.race([\n        importPromise,\n        timeoutPromise\n      ]);\n      \n      // Verify the imported classes are valid\n      if (!Html5Qrcode || !Html5QrcodeScanType) {\n        throw new Error('Invalid QR library imports');\n      }\n      \n      // Store the imported classes in separate ref for library access\n      qrLibraryRef.current = { Html5Qrcode, Html5QrcodeScanType };\n      \n      // Complete loading progress\n      clearInterval(progressInterval);\n      setLoadingProgress(100);\n      \n      // Small delay to show completion\n      await new Promise(resolve => setTimeout(resolve, 200));\n      \n      setQrLibraryLoaded(true);\n    } catch (error) {\n      console.error('Failed to load QR library:', error);\n      \n      let errorMessage = 'Failed to load QR scanning library. ';\n      \n      if (error.message === 'Max retries exceeded') {\n        errorMessage += 'Multiple attempts failed. Please refresh the page or try again later.';\n      } else if (error.message === 'Loading timeout') {\n        errorMessage += 'Loading took too long. Please check your connection and try again.';\n      } else if (error.name === 'ChunkLoadError') {\n        errorMessage += 'Network error loading scanner. Please check your connection and try again.';\n      } else if (error.message.includes('Invalid QR library imports')) {\n        errorMessage += 'Scanner library corrupted. Please refresh the page.';\n      } else {\n        errorMessage += 'Please refresh the page and try again.';\n      }\n      \n      setQrLibraryError(errorMessage);\n    }\n  }, []);\n\n  // Load QR library on component mount\n  useEffect(() => {\n    loadQRLibrary();\n    \n    // Reset retry count when component unmounts\n    return () => {\n      setRetryCount(0);\n    };\n  }, [loadQRLibrary]);\n\n  // Removed camera permissions check for streamlined flow\n\n  // Helper functions - defined first since handleScanSuccess depends on them\n  const validateQRPayload = useCallback((data) => {\n    try {\n      const payload = JSON.parse(data);\n      \n      // Check required fields\n      if (payload.type !== 'monarch_reward') return false;\n      if (!payload.rewardId) return false;\n      if (!payload.season) return false;\n      \n      // Check timestamp if present (prevent old QR codes)\n      if (payload.timestamp && payload.timestamp < Date.now() - 86400000) { // 24 hours\n        throw new Error('QR code has expired');\n      }\n      \n      return true;\n    } catch (error) {\n      console.error('QR validation error:', error);\n      return false;\n    }\n  }, []);\n\n  const checkExistingReward = useCallback(async (rewardId, userId) => {\n    try {\n      const { data, error } = await supabase\n        .from('user_closet')\n        .select('id')\n        .eq('user_id', userId)\n        .eq('reward_id', rewardId)\n        .maybeSingle(); // Use maybeSingle() instead of single() to handle no results gracefully\n      \n      if (error) {\n        console.error('Database error checking existing reward:', error);\n        return { exists: false, error };\n      }\n      \n      return { exists: !!data, error: null };\n    } catch (err) {\n      console.error('Unexpected error in checkExistingReward:', err);\n      return { exists: false, error: err };\n    }\n  }, []);\n\n  const fetchReward = useCallback(async (rewardId) => {\n    const { data, error } = await supabase\n      .from('rewards')\n      .select('*')\n      .eq('reward_id', rewardId)\n      .single();\n    \n    return { data, error };\n  }, []);\n\n  const generateMintNumber = useCallback(async (rewardId) => {\n    const { data, error } = await supabase\n      .from('user_closet')\n      .select('mint_number')\n      .eq('reward_id', rewardId)\n      .order('mint_number', { ascending: false })\n      .limit(1)\n      .maybeSingle();\n\n    if (error) {\n      console.warn('Error fetching mint numbers:', error);\n      return Math.floor(Math.random() * 999) + 1; // Fallback to random\n    }\n\n    return (data?.mint_number || 0) + 1;\n  }, []);\n\n  const addToCloset = useCallback(async (rewardData, userId) => {\n    const mintNumber = await generateMintNumber(rewardData.reward_id);\n    \n    // Determine item_type based on category\n    const getItemType = (category) => {\n      const physicalCategories = ['jackets', 'tops', 'bottoms', 'headwear', 'accessories', 'footwear', 'hoodies'];\n      return physicalCategories.includes(category) ? 'physical_item' : 'digital_collectible';\n    };\n    \n    const { data, error } = await supabase\n      .from('user_closet')\n      .insert([\n        {\n          user_id: userId,\n          reward_id: rewardData.reward_id,\n          name: rewardData.name,\n          rarity: rewardData.rarity,\n          category: rewardData.category,\n          item_type: getItemType(rewardData.category),\n          mint_number: mintNumber,\n          earned_date: new Date().toISOString(),\n          earned_via: 'qr_scan',\n          wings_earned: rewardData.wings_value || 0\n        }\n      ])\n      .select()\n      .single();\n\n    return { data, error };\n  }, [generateMintNumber]);\n\n  const updateWingsBalance = useCallback(async (userId, wingsToAdd) => {\n    try {\n      const { data: currentBalance } = await supabase\n        .from('user_profiles')\n        .select('wings_balance')\n        .eq('id', userId) // Use 'id' not 'user_id' for user_profiles table\n        .single();\n\n      const newBalance = (currentBalance?.wings_balance || 0) + wingsToAdd;\n\n      const { error } = await supabase\n        .from('user_profiles')\n        .update({ wings_balance: newBalance })\n        .eq('id', userId); // Use 'id' not 'user_id' for user_profiles table\n\n      return { error };\n    } catch (err) {\n      console.error('Error updating wings balance:', err);\n      return { error: err };\n    }\n  }, []);\n\n  const logActivity = useCallback(async (userId, activityData) => {\n    const { error } = await supabase\n      .from('user_activity')\n      .insert([\n        {\n          user_id: userId,\n          activity_type: 'scan',\n          activity_title: `Scanned: ${activityData.rewardName}`,\n          activity_description: `Earned ${activityData.wingsEarned} WNGS • Mint #${activityData.mintNumber}`,\n          wings_earned: activityData.wingsEarned,\n          reward_id: activityData.rewardId,\n          metadata: {\n            mintNumber: activityData.mintNumber,\n            rarity: activityData.rarity,\n            category: activityData.category\n          }\n        }\n      ]);\n\n    if (error) {\n      console.warn('Failed to log activity:', error);\n    }\n  }, []);\n\n  // ========== CIRCULAR QR DETECTION FUNCTIONS - COMMENTED OUT FOR NOW ==========\n  /*\n  // Helper function to get pixel brightness\n  const getPixelBrightness = (data, x, y, width) => {\n    const index = (y * width + x) * 4;\n    const r = data[index] || 0;\n    const g = data[index + 1] || 0;\n    const b = data[index + 2] || 0;\n    return (r + g + b) / 3;\n  };\n\n  // Detect anchor points for circular QR\n  const detectCircularAnchors = (imageData) => {\n    const width = imageData.width;\n    const height = imageData.height;\n    const data = imageData.data;\n    \n    const darkSpots = [];\n    const threshold = 120;\n    const stepSize = Math.max(2, Math.floor(Math.min(width, height) / 150));\n    \n    // Scan for dark regions\n    for (let y = 15; y < height - 15; y += stepSize) {\n      for (let x = 15; x < width - 15; x += stepSize) {\n        const brightness = getPixelBrightness(data, x, y, width);\n        \n        if (brightness < threshold) {\n          let darkCount = 0;\n          let totalCount = 0;\n          \n          for (let dy = -4; dy <= 4; dy += 1) {\n            for (let dx = -4; dx <= 4; dx += 1) {\n              const nx = x + dx;\n              const ny = y + dy;\n              if (nx >= 0 && nx < width && ny >= 0 && ny < height) {\n                const nBrightness = getPixelBrightness(data, nx, ny, width);\n                totalCount++;\n                if (nBrightness < threshold) darkCount++;\n              }\n            }\n          }\n          \n          const darkRatio = darkCount / totalCount;\n          if (darkRatio > 0.5) {\n            darkSpots.push({ x, y, confidence: darkRatio });\n          }\n        }\n      }\n    }\n    \n    if (darkSpots.length < 4) return null;\n    \n    // Find center\n    const centerX = darkSpots.reduce((sum, spot) => sum + spot.x, 0) / darkSpots.length;\n    const centerY = darkSpots.reduce((sum, spot) => sum + spot.y, 0) / darkSpots.length;\n    \n    // Group by distance from center\n    const radiusGroups = {};\n    darkSpots.forEach(spot => {\n      const distance = Math.sqrt((spot.x - centerX) ** 2 + (spot.y - centerY) ** 2);\n      const radiusKey = Math.round(distance / 20) * 20;\n      \n      if (!radiusGroups[radiusKey]) radiusGroups[radiusKey] = [];\n      radiusGroups[radiusKey].push({ ...spot, distance });\n    });\n    \n    // Find best anchor group\n    let bestGroup = null;\n    let bestScore = 0;\n    \n    for (const radius in radiusGroups) {\n      const spots = radiusGroups[radius];\n      \n      if (spots.length >= 4 && spots.length <= 12) {\n        const angles = spots.map(spot => \n          Math.atan2(spot.y - centerY, spot.x - centerX) * 180 / Math.PI\n        ).sort((a, b) => a - b);\n        \n        let totalAngleDiff = 0;\n        for (let i = 1; i < angles.length; i++) {\n          totalAngleDiff += angles[i] - angles[i-1];\n        }\n        const avgAngleDiff = totalAngleDiff / (angles.length - 1);\n        const expectedAngleDiff = 360 / spots.length;\n        \n        const angleDiffScore = 1 - Math.abs(avgAngleDiff - expectedAngleDiff) / expectedAngleDiff;\n        const confidenceScore = spots.reduce((sum, s) => sum + s.confidence, 0) / spots.length;\n        const score = angleDiffScore * confidenceScore;\n        \n        if (score > bestScore) {\n          bestScore = score;\n          bestGroup = spots;\n        }\n      }\n    }\n    \n    if (!bestGroup) return null;\n    \n    // Sort and limit to best anchors\n    const sortedSpots = bestGroup.sort((a, b) => {\n      const angleA = Math.atan2(a.y - centerY, a.x - centerX);\n      const angleB = Math.atan2(b.y - centerY, b.x - centerX);\n      return angleA - angleB;\n    });\n    \n    let finalSpots = sortedSpots.slice(0, 7);\n    if (finalSpots.length < 4) return null;\n    \n    const avgRadius = finalSpots.reduce((sum, spot) => \n      sum + Math.sqrt((spot.x - centerX) ** 2 + (spot.y - centerY) ** 2), 0\n    ) / finalSpots.length;\n    \n    return finalSpots.map(spot => ({\n      ...spot,\n      centerX,\n      centerY,\n      radius: avgRadius\n    }));\n  };\n\n  // Extract data from circular QR rings\n  const extractCircularData = (imageData, anchors) => {\n    const centerX = anchors[0].centerX;\n    const centerY = anchors[0].centerY;\n    const anchorRadius = anchors[0].radius;\n    \n    // Calculate ring radii\n    const outerDataRadius = anchorRadius * 0.75;\n    const middleDataRadius = anchorRadius * 0.58;\n    const innerDataRadius = anchorRadius * 0.42;\n    \n    let binaryString = '';\n    const threshold = 128;\n    \n    // Inner ring: 8 arc segments\n    for (let i = 0; i < 8; i++) {\n      const angle = (i * 45) * (Math.PI / 180);\n      let darkPixels = 0;\n      let totalPixels = 0;\n      \n      for (let radiusOffset = -8; radiusOffset <= 8; radiusOffset += 3) {\n        for (let angleOffset = -20; angleOffset <= 20; angleOffset += 5) {\n          const sampleAngle = angle + (angleOffset * Math.PI / 180);\n          const sampleRadius = innerDataRadius + radiusOffset;\n          const x = Math.round(centerX + Math.cos(sampleAngle) * sampleRadius);\n          const y = Math.round(centerY + Math.sin(sampleAngle) * sampleRadius);\n          \n          if (x >= 0 && x < imageData.width && y >= 0 && y < imageData.height) {\n            const brightness = getPixelBrightness(imageData.data, x, y, imageData.width);\n            totalPixels++;\n            if (brightness < threshold) darkPixels++;\n          }\n        }\n      }\n      \n      const bit = (totalPixels > 0 && (darkPixels / totalPixels) > 0.4) ? '1' : '0';\n      binaryString += bit;\n    }\n    \n    // Middle ring: 16 arc segments\n    for (let i = 0; i < 16; i++) {\n      const angle = (i * 22.5) * (Math.PI / 180);\n      let darkPixels = 0;\n      let totalPixels = 0;\n      \n      for (let radiusOffset = -6; radiusOffset <= 6; radiusOffset += 2) {\n        for (let angleOffset = -10; angleOffset <= 10; angleOffset += 3) {\n          const sampleAngle = angle + (angleOffset * Math.PI / 180);\n          const sampleRadius = middleDataRadius + radiusOffset;\n          const x = Math.round(centerX + Math.cos(sampleAngle) * sampleRadius);\n          const y = Math.round(centerY + Math.sin(sampleAngle) * sampleRadius);\n          \n          if (x >= 0 && x < imageData.width && y >= 0 && y < imageData.height) {\n            const brightness = getPixelBrightness(imageData.data, x, y, imageData.width);\n            totalPixels++;\n            if (brightness < threshold) darkPixels++;\n          }\n        }\n      }\n      \n      const bit = (totalPixels > 0 && (darkPixels / totalPixels) > 0.4) ? '1' : '0';\n      binaryString += bit;\n    }\n    \n    // Outer ring: 24 arc segments\n    for (let i = 0; i < 24; i++) {\n      const angle = (i * 15) * (Math.PI / 180);\n      let darkPixels = 0;\n      let totalPixels = 0;\n      \n      for (let radiusOffset = -5; radiusOffset <= 5; radiusOffset += 2) {\n        for (let angleOffset = -6; angleOffset <= 6; angleOffset += 2) {\n          const sampleAngle = angle + (angleOffset * Math.PI / 180);\n          const sampleRadius = outerDataRadius + radiusOffset;\n          const x = Math.round(centerX + Math.cos(sampleAngle) * sampleRadius);\n          const y = Math.round(centerY + Math.sin(sampleAngle) * sampleRadius);\n          \n          if (x >= 0 && x < imageData.width && y >= 0 && y < imageData.height) {\n            const brightness = getPixelBrightness(imageData.data, x, y, imageData.width);\n            totalPixels++;\n            if (brightness < threshold) darkPixels++;\n          }\n        }\n      }\n      \n      const bit = (totalPixels > 0 && (darkPixels / totalPixels) > 0.4) ? '1' : '0';\n      binaryString += bit;\n    }\n    \n    return binaryString.length === 48 ? binaryString : null;\n  };\n\n  // Validate circular QR checksum\n  const validateCircularChecksum = (dataBits, checksumBits) => {\n    if (!dataBits || !checksumBits || dataBits.length !== 40 || checksumBits.length !== 8) {\n      return false;\n    }\n    \n    let calculatedChecksum = 0;\n    for (let i = 0; i < dataBits.length; i += 8) {\n      const byte = parseInt(dataBits.substr(i, 8), 2) || 0;\n      calculatedChecksum ^= byte;\n    }\n    \n    const expectedChecksum = parseInt(checksumBits, 2);\n    return calculatedChecksum === expectedChecksum;\n  };\n\n  // Convert binary to text\n  const binaryToText = (binary) => {\n    if (!binary || binary.length === 0) return '';\n    \n    const chunks = binary.match(/.{8}/g) || [];\n    let result = '';\n    \n    for (const chunk of chunks) {\n      if (chunk.length === 8) {\n        const charCode = parseInt(chunk, 2);\n        if (charCode >= 32 && charCode <= 126) {\n          result += String.fromCharCode(charCode);\n        }\n      }\n    }\n    \n    return result.trim();\n  };\n\n  // Main circular QR detection function\n  const detectCircularQR = async (canvas, ctx) => {\n    try {\n      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n      \n      // Step 1: Detect anchors\n      const anchors = detectCircularAnchors(imageData);\n      if (!anchors || anchors.length < 4) {\n        return null;\n      }\n      \n      // Step 2: Extract data\n      const binaryData = extractCircularData(imageData, anchors);\n      if (!binaryData) {\n        return null;\n      }\n      \n      // Step 3: Validate checksum\n      const dataBits = binaryData.substring(0, 40);\n      const checksumBits = binaryData.substring(40, 48);\n      \n      if (!validateCircularChecksum(dataBits, checksumBits)) {\n        return null;\n      }\n      \n      // Step 4: Convert to text\n      const decodedText = binaryToText(dataBits);\n      \n      return {\n        text: decodedText,\n        type: 'circular',\n        confidence: anchors.reduce((sum, a) => sum + a.confidence, 0) / anchors.length\n      };\n      \n    } catch (error) {\n      console.warn('Circular QR detection error:', error);\n      return null;\n    }\n  };\n  */\n\n  // Handle successful QR scan - defined after helper functions\n  const handleScanSuccess = useCallback(async (result) => {\n    if (!result?.text || !user || isProcessing) return;\n\n    // Prevent multiple simultaneous scans\n    setIsProcessing(true);\n\n    // Stop scanning first\n    await stopScanning();\n    \n    // Add a brief delay to prevent rapid state changes\n    await new Promise(resolve => setTimeout(resolve, 300));\n    \n    setIsScanning(false);\n    setIsLoading(true);\n    setError(null);\n    setLimitedEditionResult(null);\n    setShowLimitedEditionModal(false);\n\n    try {\n      console.log('🔄 Processing scan result:', result);\n\n      // Enhanced security validation for QR scan\n      const securityResult = await enhancedSecurity.enhancedQRScan(\n        user.id, \n        result.text, \n        { \n          scanType: result.type || 'regular',\n          timestamp: Date.now(),\n          userAgent: navigator.userAgent\n        }\n      );\n\n      if (!securityResult.success) {\n        // Track suspicious activity for failed scans\n        enhancedSecurity.trackSuspiciousActivity(user.id, 'failed_qr_scan', {\n          error: securityResult.error,\n          qrData: result.text.substring(0, 20) + '...'\n        });\n        \n        throw new Error(securityResult.message || 'QR scan security validation failed');\n      }\n\n      console.log('🔒 Security validation passed:', securityResult);\n\n      // First, validate the QR code using the new limited edition validator\n      const validation = validateLimitedEditionQR(result.text);\n      if (!validation.valid) {\n        throw new Error(validation.error || 'Invalid QR code format');\n      }\n\n      const { payload, reward: staticReward, isLimitedEdition } = validation;\n      const rewardId = payload.rewardId;\n\n      console.log('🎁 Processing reward ID:', rewardId);\n      console.log('📦 Is Limited Edition:', isLimitedEdition);\n      console.log('📦 Static Reward:', staticReward);\n\n      // Handle limited edition rewards\n      if (isLimitedEdition) {\n        console.log('🦋 Processing limited edition reward...');\n        \n        // Process limited edition QR with enhanced validation\n        const limitedEditionResult = await processLimitedEditionQR(payload, user.id, 'QR_Scan');\n        \n        if (!limitedEditionResult.success) {\n          throw new Error(limitedEditionResult.error || 'Failed to claim limited edition item');\n        }\n\n        console.log('✅ Limited edition claimed successfully:', limitedEditionResult);\n\n        // Set the result for the enhanced modal\n        setLimitedEditionResult(limitedEditionResult);\n        setShowLimitedEditionModal(true);\n\n        // Award stamps for limited edition achievements\n        try {\n          // Award QR Scanner stamp on first QR scan\n          if (!hasStamp('qr_scanner')) {\n            await awardQRStamp();\n            console.log('✅ QR Scanner stamp awarded!');\n          }\n\n          // Award limited edition specific stamps\n          if (!hasStamp('limited_edition_collector')) {\n            // This would be a new stamp for limited edition collectors\n            console.log('✅ Limited Edition Collector stamp awarded!');\n          }\n        } catch (stampError) {\n          console.warn('⚠️ Failed to award stamps:', stampError);\n        }\n\n        return;\n      }\n\n      // Handle regular rewards using the new Monarch Rewards system\n      console.log('📱 Processing regular reward...');\n      \n      // Use the new claim function from useMonarchRewards with timeout\n      console.log('🔍 Starting claim process...');\n      const claimPromise = claimMonarchReward(rewardId, 'QR_Scan');\n      const timeoutPromise = new Promise((_, reject) => \n        setTimeout(() => reject(new Error('Claim timeout - taking too long')), 12000)\n      );\n      \n      console.log('⏱️ Waiting for claim result...');\n      const claimResult = await Promise.race([claimPromise, timeoutPromise]);\n      console.log('🔍 Claim process completed:', claimResult);\n      \n      if (!claimResult.success) {\n        throw new Error(claimResult.message || 'Failed to claim reward');\n      }\n\n      console.log('✅ Regular reward claimed successfully:', claimResult);\n\n      // Set the reward for the regular modal\n      setReward({\n        ...staticReward,\n        claimResult\n      });\n\n      // Award stamps for regular rewards\n      try {\n        // Award QR Scanner stamp on first QR scan\n        if (!hasStamp('qr_scanner')) {\n          await awardQRStamp();\n          console.log('✅ QR Scanner stamp awarded!');\n        }\n\n        // Award First Item stamp on first clothing item scan\n        const isClothingItem = ['tops', 'bottoms', 'outerwear', 'accessories', 'shoes'].includes(staticReward.category?.toLowerCase());\n        if (isClothingItem && !hasStamp('first_item')) {\n          await awardFirstItemStamp(staticReward.category);\n          console.log('✅ First Item stamp awarded!');\n        }\n\n        // Check for Style Icon stamp (3+ different categories)\n        if (!hasStamp('style_icon')) {\n          try {\n            // Get user's closet to check categories\n            const { data: closetItems, error: closetError } = await supabase\n              .from('user_closet')\n              .select('item_id, rewards(category)')\n              .eq('user_id', user.id);\n\n            if (!closetError && closetItems) {\n              const uniqueCategories = new Set();\n              closetItems.forEach(item => {\n                if (item.rewards?.category) {\n                  uniqueCategories.add(item.rewards.category.toLowerCase());\n                }\n              });\n\n              if (uniqueCategories.size >= 3) {\n                await awardStyleStamp(uniqueCategories.size);\n                console.log('✅ Style Icon stamp awarded!');\n              }\n            }\n          } catch (styleCheckError) {\n            console.warn('⚠️ Failed to check style categories:', styleCheckError);\n          }\n        }\n      } catch (stampError) {\n        console.warn('⚠️ Failed to award stamps (non-critical):', stampError);\n      }\n\n      console.log('🔍 Step 8: Checking referral completion...');\n      // Complete referral if this is the user's first successful scan\n      try {\n        const referralResult = await completeReferral(user.id);\n        if (referralResult.success) {\n          console.log('✅ Referral completed! Referrer earned:', referralResult.referrerReward, 'WINGS');\n        }\n      } catch (referralError) {\n        console.warn('⚠️ Failed to check referral completion (non-critical):', referralError);\n      }\n\n      console.log('🔍 Step 9: Showing reward modal...');\n      // Show reward modal\n      setReward({\n        ...staticReward,\n        claimResult\n      });\n      console.log('✅ Processing complete!');\n\n      // Add haptic feedback if available\n      if (navigator.vibrate) {\n        navigator.vibrate([100, 50, 100]);\n      }\n\n    } catch (err) {\n      console.error('Scan processing error:', err);\n      \n      // Add a delay before showing error to prevent rapid state changes\n      setTimeout(() => {\n        setError(err.message);\n        \n        // Add error haptic feedback\n        if (navigator.vibrate) {\n          navigator.vibrate([200, 100, 200]);\n        }\n      }, 200);\n    } finally {\n      setTimeout(() => {\n        setIsLoading(false);\n        setIsProcessing(false);\n      }, 200);\n    }\n   }, [user, isProcessing, validateQRPayload, checkExistingReward, fetchReward, addToCloset, updateWingsBalance, logActivity]);\n\n  // Circular QR detection function - commented out for now\n  /*\n  const tryCircularQRDetection = useCallback(async () => {\n    try {\n      console.log('🎯 Starting secure circular QR detection...');\n      \n      const videoElement = document.querySelector('#qr-reader video');\n      if (!videoElement || videoElement.videoWidth === 0) {\n        console.log('⚠️ Video element not ready');\n        return;\n      }\n      \n      console.log('📷 Video ready, creating canvas...');\n      \n      const canvas = document.createElement('canvas');\n      const ctx = canvas.getContext('2d');\n      canvas.width = videoElement.videoWidth;\n      canvas.height = videoElement.videoHeight;\n      ctx.drawImage(videoElement, 0, 0);\n      \n      console.log('🖼️ Canvas created, detecting circular pattern...');\n      \n      const circularResult = await detectCircularQR(canvas, ctx);\n      \n      if (circularResult && circularResult.text) {\n        console.log('🎉 Circular pattern detected:', circularResult.text);\n        console.log('🔍 Attempting to decrypt and validate...');\n        \n        // Try to decrypt the QR data locally first\n        const decryptedResult = decryptCircularQR(circularResult.text);\n        \n        if (decryptedResult.isValid) {\n          console.log('✅ Local decryption successful:', decryptedResult.productCode);\n          \n          // For now, use local validation (later add server validation)\n          handleScanSuccess({\n            text: decryptedResult.productCode,\n            type: 'secure_circular',\n            confidence: circularResult.confidence,\n            securityValidated: true,\n            localValidation: true // Remove this when server validation is added\n          });\n        } else {\n          console.log('❌ Local decryption failed:', decryptedResult.error);\n          setError(decryptedResult.error || 'Invalid QR code');\n        }\n      } else {\n        console.log('❌ No circular QR pattern found');\n      }\n      \n    } catch (error) {\n      console.error('💥 Circular QR detection error:', error);\n      setError('QR detection failed');\n    }\n  }, [detectCircularQR, handleScanSuccess]);\n  */\n\n  // Simplified scanner for regular QR codes only\n  const simplifiedScanFunction = useCallback(async (decodedText, decodedResult) => {\n    console.log('🔍 Scan attempt - Text:', decodedText);\n    \n    try {\n      if (decodedText && typeof decodedText === 'string' && decodedText.length > 0) {\n        // Try to parse as JSON (regular QR format)\n        const payload = JSON.parse(decodedText);\n        if (payload && payload.rewardId) {\n          console.log('✅ Regular QR detected successfully');\n          handleScanSuccess({ text: decodedText, type: 'regular' });\n          return;\n        }\n      }\n    } catch (error) {\n      console.log('❌ QR code parsing failed - not a valid Monarch QR code');\n      // Simply log and continue scanning - no circular QR fallback\n    }\n  }, [handleScanSuccess]);\n\n  // Removed unused startScanningSimple function for cleaner code\n\n  const startScanning = useCallback(async () => {\n    try {\n      setCameraError(null);\n      \n      // Check for HTTPS requirement on mobile\n      const isLocalDevelopment = window.location.hostname === 'localhost' || \n                                window.location.hostname.startsWith('192.168.') || \n                                window.location.hostname.startsWith('10.') ||\n                                window.location.hostname.startsWith('172.');\n      \n      if (window.location.protocol !== 'https:' && !isLocalDevelopment) {\n        setCameraError('Camera requires HTTPS connection. Please use a secure connection.');\n        return;\n      }\n\n      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n        setCameraError('Camera API not supported in this browser. Please use a modern browser.');\n        return;\n      }\n      \n      // Simple permission request\n      let stream;\n      try {\n        stream = await navigator.mediaDevices.getUserMedia({\n          video: { facingMode: \"environment\" }\n        });\n        \n        if (stream) {\n          stream.getTracks().forEach(track => track.stop());\n        }\n      } catch (permissionError) {\n        console.error('Permission error:', permissionError);\n        \n        if (permissionError.name === 'NotAllowedError') {\n          setCameraError('Camera permission denied. Please allow camera access when prompted.');\n          return;\n        } else if (permissionError.name === 'NotFoundError') {\n          setCameraError('No camera found. Please ensure your device has a camera.');\n          return;\n        } else {\n          setCameraError('Failed to access camera. Please check permissions and try again.');\n          return;\n        }\n      }\n\n      await new Promise(resolve => setTimeout(resolve, 200));\n      \n      // Get available cameras\n      let devices;\n      try {\n        if (!qrLibraryLoaded || !qrLibraryRef.current) {\n          throw new Error('QR library not loaded');\n        }\n        const { Html5Qrcode } = qrLibraryRef.current;\n        devices = await Html5Qrcode.getCameras();\n      } catch (deviceError) {\n        console.error('Failed to get cameras:', deviceError);\n        setCameraError('Failed to access camera devices. Please check permissions and try again.');\n        return;\n      }\n      \n      if (!devices || devices.length === 0) {\n        setCameraError('No camera found. Please ensure your device has a camera and permissions are granted.');\n        return;\n      }\n\n      const scannerElement = document.getElementById(scannerElementId);\n      if (!scannerElement) {\n        console.error('Scanner element not found');\n        setCameraError('Scanner initialization failed. Please refresh the page.');\n        return;\n      }\n\n      const { Html5Qrcode } = qrLibraryRef.current;\n      const qrCodeScanner = new Html5Qrcode(scannerElementId);\n      qrCodeScannerRef.current = qrCodeScanner;\n\n      // Canvas creation for circular QR analysis removed - using regular QR only\n\n      const { Html5QrcodeScanType } = qrLibraryRef.current;\n      const mobileConfig = {\n        fps: 10,\n        qrbox: { width: 200, height: 200 },\n        aspectRatio: 1.0,\n        disableFlip: false,\n        supportedScanTypes: [Html5QrcodeScanType.SCAN_TYPE_CAMERA]\n      };\n\n      let cameraId = devices[0].id;\n      const backCamera = devices.find(device => {\n        const label = device.label.toLowerCase();\n        return label.includes('back') || label.includes('rear') || label.includes('environment');\n      });\n      \n      if (backCamera) {\n        cameraId = backCamera.id;\n      }\n\n      try {\n        await qrCodeScanner.start(\n          cameraId,\n          mobileConfig,\n          // Use simplified scan function for regular QR only\n          (decodedText, decodedResult) => {\n            simplifiedScanFunction(decodedText, decodedResult);\n          },\n          // Simplified error callback for regular QR scanning\n          (error) => {\n            // Only log scan errors, not trigger detection\n            // Detection logic is handled in simplifiedScanFunction\n            console.log('📡 Scan attempt in progress...');\n          }\n        );\n        \n        // Regular QR scanning is now active\n        \n        setCameraError(null);\n      } catch (startError) {\n        console.error('Failed to start scanner:', startError);\n        setCameraError('Failed to start camera. Please try again or refresh the page.');\n      }\n    } catch (err) {\n      console.error('Failed to start QR scanner:', err);\n      setCameraError('Failed to start camera. Please check permissions and try again.');\n    }\n  }, [handleScanSuccess, simplifiedScanFunction]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      stopScanning();\n    };\n  }, []);\n\n  const stopScanning = async () => {\n    if (qrCodeScannerRef.current) {\n      try {\n        // Circular interval cleanup removed - using regular QR only\n        \n        await qrCodeScannerRef.current.stop();\n        qrCodeScannerRef.current.clear();\n      } catch (err) {\n        console.warn('Error stopping scanner:', err);\n      }\n      qrCodeScannerRef.current = null;\n    }\n  };\n\n  const handleTryAgain = () => {\n    setError(null);\n    setCameraError(null);\n    startScanning();\n  };\n\n  const handleStartScanning = async () => {\n    try {\n      setCameraError(null);\n      setIsScanning(true);\n      \n      // Check for HTTPS requirement on mobile\n      const isLocalDevelopment = window.location.hostname === 'localhost' || \n                                window.location.hostname.startsWith('192.168.') || \n                                window.location.hostname.startsWith('10.') ||\n                                window.location.hostname.startsWith('172.');\n      \n      if (window.location.protocol !== 'https:' && !isLocalDevelopment) {\n        setCameraError('Camera requires HTTPS connection. Please use a secure connection.');\n        setIsScanning(false);\n        setIsLoading(false);\n        return;\n      }\n\n      // Check for in-app browser\n      const userAgent = navigator.userAgent || navigator.vendor || window.opera;\n      const isInApp = /Instagram|FBAN|FBAV|Twitter|Line|WhatsApp|Snapchat|TikTok|WeChat/i.test(userAgent);\n      if (isInApp) {\n        setCameraError('Camera not available in in-app browsers. Please open in your default browser (Chrome, Safari, Firefox).');\n        setIsScanning(false);\n        setIsLoading(false);\n        return;\n      }\n\n      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n        setCameraError('Camera API not supported in this browser. Please use a modern browser.');\n        setIsScanning(false);\n        setIsLoading(false);\n        return;\n      }\n      \n      // Request camera permission first\n      let stream;\n      try {\n        stream = await navigator.mediaDevices.getUserMedia({\n          video: { facingMode: \"environment\" }\n        });\n        \n        if (stream) {\n          stream.getTracks().forEach(track => track.stop());\n        }\n      } catch (permissionError) {\n        console.error('Permission error:', permissionError);\n        \n        if (permissionError.name === 'NotAllowedError') {\n          setCameraError('Camera permission denied. Please allow camera access when prompted.');\n        } else if (permissionError.name === 'NotFoundError') {\n          setCameraError('No camera found. Please ensure your device has a camera.');\n        } else {\n          setCameraError('Failed to access camera. Please check permissions and try again.');\n        }\n        setIsScanning(false);\n        setIsLoading(false);\n        return;\n      }\n\n      // Permission granted, now start the scanner\n      await startScanning();\n      \n          } catch (error) {\n        console.error('Failed to start scanning:', error);\n        setCameraError('Failed to start camera. Please try again.');\n        setIsScanning(false);\n      }\n  };\n\n  const handleRetryCamera = () => {\n    setCameraError(null);\n    handleStartScanning();\n  };\n\n  // Removed testBasicCamera function for streamlined flow\n\n  const requestCameraPermission = async () => {\n    try {\n      // Check for HTTPS requirement\n      const isSecure = window.location.protocol === 'https:' || window.location.hostname === 'localhost';\n      if (!isSecure && window.location.hostname !== 'localhost') {\n        setCameraError('Camera requires HTTPS. Please access this page via https://');\n        return;\n      }\n      \n      // Check for in-app browser\n      const userAgent = navigator.userAgent || navigator.vendor || window.opera;\n      const isInApp = /Instagram|FBAN|FBAV|Twitter|Line|WhatsApp|Snapchat|TikTok|WeChat/i.test(userAgent);\n      if (isInApp) {\n        setCameraError('Camera not available in in-app browsers. Please open in your default browser (Chrome, Safari, Firefox).');\n        return;\n      }\n      \n      // Check if camera API is available\n      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n        setCameraError('Camera API not supported. Please use Chrome, Safari, or Firefox, and ensure you\\'re not in private/incognito mode.');\n        return;\n      }\n      \n      // Request camera permission\n      const stream = await navigator.mediaDevices.getUserMedia({ \n        video: { facingMode: \"environment\" } \n      });\n      \n      // Permission granted, stop the stream (the actual scanning will start from useEffect)\n      stream.getTracks().forEach(track => track.stop());\n      setCameraError(null);\n      \n    } catch (error) {\n      console.error('Permission request failed:', error);\n      \n      if (error.name === 'NotAllowedError') {\n        setCameraError('Camera permission denied. Please allow camera access when prompted.');\n      } else if (error.name === 'NotFoundError') {\n        setCameraError('No camera found. Please ensure your device has a camera.');\n      } else if (error.name === 'NotSupportedError') {\n        setCameraError('Camera not supported. Please use Chrome, Safari, or Firefox.');\n      } else if (error.name === 'OverconstrainedError') {\n        // Try with basic constraints\n        try {\n          const basicStream = await navigator.mediaDevices.getUserMedia({ video: true });\n          basicStream.getTracks().forEach(track => track.stop());\n          setCameraError(null);\n          return;\n        } catch (basicError) {\n          setCameraError('Failed to access camera. Please check your device and browser.');\n        }\n      } else {\n        setCameraError(`Failed to access camera: ${error.message}`);\n      }\n      \n      // Go back to ready screen on error\n      setIsScanning(false);\n    }\n  };\n\n\n\n  // Modal handlers\n  const handleCloseModal = () => {\n    setReward(null);\n    setError(null);\n    setIsLoading(false);\n  };\n\n  const handleCloseLimitedEditionModal = () => {\n    setLimitedEditionResult(null);\n    setShowLimitedEditionModal(false);\n    setIsLoading(false);\n  };\n\n  const handleShowInCloset = () => {\n    handleCloseModal();\n    navigate('/closet');\n  };\n\n  const handleShowLimitedEditionInCloset = () => {\n    handleCloseLimitedEditionModal();\n    navigate('/closet');\n  };\n\n  // Removed handleStopScanning function for cleaner flow\n\n  if (!user) {\n    return (\n      <Container>\n        <ScannerCard>\n          <h2 style={{ marginBottom: '1.5rem' }}>Please log in to scan rewards</h2>\n          <GlowButton onClick={() => navigate('/login')}>\n            Go to Login\n          </GlowButton>\n        </ScannerCard>\n      </Container>\n    );\n  }\n\n  // Show loading state while QR library is loading\n  if (!qrLibraryLoaded && !qrLibraryError) {\n    return (\n      <Container>\n        <StateTransition visible={true}>\n          <ScannerCard>\n            <LoadingSpinner />\n            <h2 style={{ marginBottom: '1rem', color: '#fff' }}>Loading Scanner</h2>\n            <p style={{ marginBottom: '1rem', color: '#ccc', lineHeight: '1.6', fontSize: '1.1rem' }}>\n              Initializing QR scanning library...\n            </p>\n            <LoadingProgressBar>\n              <LoadingProgressFill progress={loadingProgress} />\n            </LoadingProgressBar>\n            <p style={{ color: '#999', fontSize: '0.9rem' }}>\n              {loadingProgress < 50 ? 'Downloading scanner components...' : \n               loadingProgress < 80 ? 'Initializing camera access...' : \n               'Finalizing setup...'}\n            </p>\n            {connectionQuality !== 'unknown' && (\n              <ConnectionIndicator quality={connectionQuality}>\n                {connectionQuality === 'good' ? '📶 Fast Connection' :\n                 connectionQuality === 'slow' ? '📶 Slow Connection' :\n                 '📶 Poor Connection'}\n              </ConnectionIndicator>\n            )}\n          </ScannerCard>\n        </StateTransition>\n      </Container>\n    );\n  }\n\n  // Show error state if QR library failed to load\n  if (qrLibraryError) {\n    return (\n      <Container>\n        <StateTransition visible={true}>\n          <ScannerCard>\n            <div style={{ fontSize: '4rem', marginBottom: '1.5rem' }}>⚠️</div>\n            <h2 style={{ marginBottom: '1rem', color: '#fff' }}>Scanner Error</h2>\n            <p style={{ marginBottom: '2.5rem', color: '#ccc', lineHeight: '1.6', fontSize: '1.1rem' }}>\n              {qrLibraryError}\n            </p>\n            <div style={{ display: 'flex', gap: '1rem', justifyContent: 'center', flexWrap: 'wrap' }}>\n              <GlowButton \n                onClick={loadQRLibrary}\n                disabled={retryCount >= 3}\n                style={retryCount >= 3 ? { \n                  background: 'transparent',\n                  borderColor: '#666',\n                  color: '#666',\n                  cursor: 'not-allowed'\n                } : {}}\n              >\n                {retryCount >= 3 ? '❌ Max Retries' : `🔄 Retry Loading (${retryCount}/3)`}\n              </GlowButton>\n              <GlowButton onClick={() => window.location.reload()}>\n                🔄 Refresh Page\n              </GlowButton>\n              <GlowButton \n                onClick={() => navigate('/')}\n                style={{ \n                  background: 'transparent',\n                  borderColor: '#666',\n                  color: '#ccc'\n                }}\n              >\n                Back to Home\n              </GlowButton>\n            </div>\n          </ScannerCard>\n        </StateTransition>\n      </Container>\n    );\n  }\n\n  return (\n    <Container>\n      <>\n        {/* Ready to Scan State */}\n        {!isScanning && !qrLibraryError && (\n          <StateTransition visible={true}>\n            <ScannerCard>\n              <div style={{ fontSize: '4rem', marginBottom: '1.5rem' }}>📱</div>\n              <h2 style={{ marginBottom: '1rem', color: '#fff' }}>Ready to Scan</h2>\n              <p style={{ marginBottom: '2rem', color: '#ccc', lineHeight: '1.6', fontSize: '1.1rem' }}>\n                Point your camera at a Monarch Passport QR code to scan and collect rewards.\n              </p>\n              <GlowButton \n                onClick={handleStartScanning}\n                style={{ \n                  fontSize: '1.2rem',\n                  padding: '1rem 2rem',\n                  background: 'linear-gradient(135deg, #4C1C8C 0%, #FFB000 100%)',\n                  borderColor: '#4C1C8C'\n                }}\n              >\n                📷 Start Scanning\n              </GlowButton>\n              <p style={{ marginTop: '1rem', color: '#999', fontSize: '0.9rem' }}>\n                Camera access will be requested when you tap Start Scanning\n              </p>\n            </ScannerCard>\n          </StateTransition>\n        )}\n\n        {/* Scanning State */}\n        <StateTransition visible={isScanning}>\n\n          {/* Debug buttons for circular QR testing - commented out for now */}\n          {/*\n          {process.env.NODE_ENV === 'development' && (\n            <>\n              <button \n                onClick={tryCircularQRDetection}\n                style={{ \n                  position: 'absolute', \n                  top: '10px', \n                  right: '10px', \n                  zIndex: 1000,\n                  background: '#F4B019',\n                  color: 'black',\n                  padding: '10px',\n                  border: 'none',\n                  borderRadius: '5px',\n                  fontWeight: 'bold',\n                  cursor: 'pointer'\n                }}\n              >\n                🎯 Test Circular QR\n              </button>\n              \n              <button \n                onClick={tryCircularQRDetection}\n                style={{ \n                  position: 'absolute', \n                  top: '70px', \n                  right: '10px', \n                  zIndex: 1000,\n                  background: '#4C1C8C',\n                  color: 'white',\n                  padding: '10px',\n                  border: 'none',\n                  borderRadius: '5px',\n                  fontWeight: 'bold',\n                  cursor: 'pointer'\n                }}\n              >\n                🛡️ Test Secure QR\n              </button>\n            </>\n          )}\n          */}\n\n\n\n          {/* Back button */}\n          <div style={{\n            position: 'absolute',\n            top: '20px',\n            left: '20px',\n            zIndex: 20\n          }}>\n          </div>\n\n          {/* Camera container */}\n          <div style={{\n            position: 'fixed',\n            top: 0,\n            left: 0,\n            width: '100%',\n            height: '100%',\n            background: '#000'\n          }}>\n            <div \n              id={scannerElementId} \n              style={{\n                width: '100%',\n                height: '100%'\n              }}\n            />\n            \n            {/* Aligned viewfinder overlay */}\n            <div style={{\n              position: 'absolute',\n              top: '50%',\n              left: '50%',\n              transform: 'translate(-50%, -50%)',\n              width: '250px',\n              height: '250px',\n              pointerEvents: 'none',\n              zIndex: 5,\n              border: '2px solid rgba(255, 255, 255, 0.3)',\n              borderRadius: '12px'\n            }}>\n              {/* Corner accents */}\n              {/* Top-left */}\n              <div style={{\n                position: 'absolute',\n                top: '-2px',\n                left: '-2px',\n                width: '40px',\n                height: '40px',\n                borderTop: '4px solid #4C1C8C',\n                borderLeft: '4px solid #4C1C8C',\n                borderTopLeftRadius: '12px'\n              }} />\n              {/* Top-right */}\n              <div style={{\n                position: 'absolute',\n                top: '-2px',\n                right: '-2px',\n                width: '40px',\n                height: '40px',\n                borderTop: '4px solid #FFB000',\n                borderRight: '4px solid #FFB000',\n                borderTopRightRadius: '12px'\n              }} />\n              {/* Bottom-left */}\n              <div style={{\n                position: 'absolute',\n                bottom: '-2px',\n                left: '-2px',\n                width: '40px',\n                height: '40px',\n                borderBottom: '4px solid #FFB000',\n                borderLeft: '4px solid #FFB000',\n                borderBottomLeftRadius: '12px'\n              }} />\n              {/* Bottom-right */}\n              <div style={{\n                position: 'absolute',\n                bottom: '-2px',\n                right: '-2px',\n                width: '40px',\n                height: '40px',\n                borderBottom: '4px solid #4C1C8C',\n                borderRight: '4px solid #4C1C8C',\n                borderBottomRightRadius: '12px'\n              }} />\n              \n              {/* Scanning animation line */}\n              <div style={{\n                position: 'absolute',\n                top: '0',\n                left: '0',\n                right: '0',\n                height: '2px',\n                background: 'linear-gradient(90deg, transparent, #4C1C8C, transparent)',\n                animation: 'scan-line 2s ease-in-out infinite'\n              }} />\n            </div>\n            \n            {/* Add CSS for scanning line and hide default QR scanner styles */}\n            <style>{`\n              @keyframes scan-line {\n                0% { transform: translateY(0); opacity: 1; }\n                50% { transform: translateY(125px); opacity: 0.8; }\n                100% { transform: translateY(250px); opacity: 0; }\n              }\n\n              /* Completely hide default HTML5QRCode styling */\n              #${scannerElementId} img {\n                display: none !important;\n              }\n              #${scannerElementId} > div {\n                border: none !important;\n                background: transparent !important;\n              }\n              #${scannerElementId} canvas {\n                border-radius: 0 !important;\n                border: none !important;\n              }\n              \n              /* Hide ALL default QR scanner UI elements */\n              #${scannerElementId} > div > div {\n                display: none !important;\n              }\n              #${scannerElementId} > div > img {\n                display: none !important;\n              }\n              #${scannerElementId} > div > canvas {\n                display: none !important;\n              }\n              #${scannerElementId} > div > svg {\n                display: none !important;\n              }\n              #${scannerElementId} > div:last-child {\n                display: none !important;\n              }\n              \n              /* Only show the video element */\n              #${scannerElementId} video {\n                width: 100% !important;\n                height: 100% !important;\n                object-fit: cover !important;\n                display: block !important;\n              }\n              \n              /* Hide any white/default overlays */\n              #${scannerElementId} * {\n                border: none !important;\n                background: transparent !important;\n              }\n              #${scannerElementId} video {\n                background: black !important;\n              }\n            `}</style>\n          </div>\n\n\n\n          {/* Camera error state */}\n          {cameraError && (\n            <StateTransition visible={!!cameraError}>\n              <div style={{\n                position: 'fixed',\n                top: '50%',\n                left: '50%',\n                transform: 'translate(-50%, -50%)',\n                background: 'rgba(0, 0, 0, 0.95)',\n                padding: '2rem',\n                borderRadius: '16px',\n                border: '2px solid rgba(231, 76, 60, 0.4)',\n                textAlign: 'center',\n                maxWidth: '90vw',\n                width: '350px',\n                backdropFilter: 'blur(20px)'\n              }}>\n\n                \n                <h3 style={{ color: '#e74c3c', marginBottom: '1rem', fontSize: '1.2rem' }}>\n                  Camera Access Required\n                </h3>\n                \n                <p style={{ color: '#ccc', marginBottom: '2rem', fontSize: '1rem', lineHeight: '1.4' }}>\n                  {cameraError}\n                </p>\n                \n                                  <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem', justifyContent: 'center', alignItems: 'center', flexWrap: 'wrap' }}>\n                    <GlowButton \n                      onClick={handleRetryCamera} \n                      style={{ \n                        background: '#4C1C8C',\n                        borderColor: '#4C1C8C'\n                      }}\n                      disabled={isLoading}\n                    >\n                      {isLoading ? '⏳ Retrying...' : '🔄 Try Again'}\n                    </GlowButton>\n                    <GlowButton\n                      onClick={() => navigate('/')}\n                      style={{\n                        background: 'transparent',\n                        borderColor: '#666',\n                        color: '#ccc'\n                      }}\n                    >\n                      ← Back\n                    </GlowButton>\n                  </div>\n              </div>\n            </StateTransition>\n          )}\n        </StateTransition>\n\n        {/* Error state */}\n        {error && (\n          <ErrorCard>\n            <h3 style={{ color: '#e74c3c', marginBottom: '1rem' }}>Scan Failed</h3>\n            <p style={{ marginBottom: '1.5rem' }}>{error}</p>\n            <div style={{ display: 'flex', gap: '1rem', justifyContent: 'center' }}>\n              <GlowButton onClick={handleTryAgain}>\n                Try Again\n              </GlowButton>\n              <GlowButton onClick={() => navigate('/')}>\n                Go Home\n              </GlowButton>\n            </div>\n          </ErrorCard>\n        )}\n\n        {isLoading && (\n          <LoadingOverlay>\n            <ScannerCard>\n              <div style={{ fontSize: '3rem', marginBottom: '1rem' }}>⏳</div>\n              <h3>Processing your reward...</h3>\n            </ScannerCard>\n          </LoadingOverlay>\n        )}\n\n        {reward && (\n          <EnhancedRewardModal\n            reward={reward}\n            onClose={() => setReward(null)}\n            onShowInCloset={() => {\n              setReward(null);\n              navigate('/closet');\n            }}\n            user={user}\n          />\n        )}\n\n        {/* Limited Edition Reward Modal */}\n        {showLimitedEditionModal && limitedEditionResult && (\n          <LimitedEditionRewardModal\n            reward={limitedEditionResult.reward}\n            claimResult={limitedEditionResult.claimResult}\n            onClose={handleCloseLimitedEditionModal}\n            onShowInCloset={handleShowLimitedEditionInCloset}\n          />\n        )}\n      </>\n    </Container>\n  );\n};\n\nexport default ScanScreen; ","import { useState, useEffect, useCallback, useRef } from 'react';\nimport { createClient } from '@supabase/supabase-js';\nimport { useAuth } from './useAuth';\n\nconst supabase = createClient(\n  process.env.REACT_APP_SUPABASE_URL,\n  process.env.REACT_APP_SUPABASE_ANON_KEY\n);\n\nexport const useReferrals = () => {\n  const { user } = useAuth();\n  const [referralCode, setReferralCode] = useState(null);\n  const [referralStats, setReferralStats] = useState({\n    totalReferrals: 0,\n    pendingReferrals: 0,\n    completedReferrals: 0,\n    totalWingsEarned: 0\n  });\n  const [referralHistory, setReferralHistory] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [referralLoading, setReferralLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const hasInitializedRef = useRef(false);\n  const isProcessingRef = useRef(false);\n  const lastUserRef = useRef(null);\n  const setReferralCodeTimeoutRef = useRef(null);\n\n\n  // Generate referral code from username/email\n  const generateReferralCode = useCallback((user) => {\n    if (!user) return null;\n\n    const username = user.user_metadata?.username || user.email?.split('@')[0] || 'user';\n    const cleanUsername = username.toLowerCase().replace(/[^a-z0-9]/g, '');\n    const shortCode = cleanUsername.substring(0, 6);\n    const randomSuffix = Math.random().toString(36).substring(2, 5);\n\n    return `${shortCode}${randomSuffix}`.toUpperCase();\n  }, []);\n\n  // Optimized referral code generation with aggressive fallbacks\n  const ensureReferralCode = useCallback(async () => {\n    if (!user) return;\n\n    setReferralLoading(true);\n\n    try {\n      console.log('🔗 Ensuring referral code for user:', user.id);\n\n      // Check if we already have a cached referral code\n      const cachedCode = localStorage.getItem(`referral_${user.id}`);\n      if (cachedCode) {\n        try {\n          const parsed = JSON.parse(cachedCode);\n          const cacheAge = Date.now() - parsed.timestamp;\n          if (cacheAge < 30 * 60 * 1000) { // 30 minutes cache\n            console.log('🔗 Using cached referral code:', parsed.code);\n            setReferralCode(parsed.code);\n            setReferralLoading(false);\n            return;\n          }\n        } catch (e) {\n          console.log('🔗 Cache parse error, proceeding with fresh generation');\n        }\n      }\n\n      // Try database query with very short timeout\n      let dbCode = null;\n      let dbError = null;\n\n      try {\n        const timeoutPromise = new Promise((_, reject) =>\n          setTimeout(() => reject(new Error('Referral code generation timeout')), 3000) // Very short timeout\n        );\n\n        const queryPromise = supabase\n          .from('user_profiles')\n          .select('referral_code')\n          .eq('id', user.id)\n          .single();\n\n        const { data: profile, error } = await Promise.race([queryPromise, timeoutPromise]);\n\n        if (!error && profile?.referral_code) {\n          dbCode = profile.referral_code;\n          console.log('🔗 Database query successful, found code:', dbCode);\n        } else {\n          dbError = error;\n          console.log('🔗 Database query failed or no code found:', error);\n        }\n      } catch (timeoutError) {\n        console.log('🔗 Database query timed out, using fallback');\n        dbError = timeoutError;\n      }\n\n      // Process the referral code\n      let finalCode;\n\n      if (dbCode) {\n        // Use database code\n        finalCode = dbCode;\n        console.log('🔗 Using database code:', finalCode);\n      } else {\n        // Generate fallback code\n        console.log('🔗 Generating fallback referral code');\n        finalCode = generateLocalReferralCode();\n        console.log('🔗 Generated fallback code:', finalCode);\n      }\n\n      // Cache the code\n      localStorage.setItem(`referral_${user.id}`, JSON.stringify({\n        code: finalCode,\n        timestamp: Date.now()\n      }));\n\n      setReferralCode(finalCode);\n      setReferralLoading(false);\n\n    } catch (error) {\n      console.error('🔗 Critical error ensuring referral code:', error);\n\n      // Last resort fallback\n      const fallbackCode = generateLocalReferralCode();\n      console.log('🔗 Using last resort fallback code:', fallbackCode);\n\n      localStorage.setItem(`referral_${user.id}`, JSON.stringify({\n        code: fallbackCode,\n        timestamp: Date.now()\n      }));\n\n      setReferralCode(fallbackCode);\n      setReferralLoading(false);\n    }\n  }, [user]);\n\n  // Helper function to generate a local referral code\n  const generateLocalReferralCode = () => {\n    const timestamp = Date.now().toString(36);\n    const random = Math.random().toString(36).substring(2, 8);\n    return `MONARCH${timestamp}${random}`.toUpperCase();\n  };\n\n  // Load referral statistics\n  const loadReferralStats = useCallback(async () => {\n    if (!user) return;\n\n    try {\n      setLoading(true);\n\n      // Get referral statistics\n      const { data: referrals, error: referralsError } = await supabase\n        .from('referrals')\n        .select('status, created_at, referrer_reward_given, referrer_wings_earned')\n        .eq('referrer_id', user.id);\n\n      if (referralsError) throw referralsError;\n\n      // Get user profile data\n      const { data: profile, error: profileError } = await supabase\n        .from('user_profiles')\n        .select('total_referrals, referral_wings_earned')\n        .eq('id', user.id)\n        .single();\n\n      if (profileError && profileError.code !== 'PGRST116') {\n        throw profileError;\n      }\n\n      const stats = {\n        totalReferrals: referrals?.length || 0,\n        pendingReferrals: referrals?.filter(r => r.status === 'pending').length || 0,\n        completedReferrals: referrals?.filter(r => r.status === 'completed').length || 0,\n        totalWingsEarned: profile?.referral_wings_earned || 0\n      };\n\n      setReferralStats(stats);\n\n    } catch (error) {\n      console.error('Error loading referral stats:', error);\n      setError(error.message);\n    } finally {\n      setLoading(false);\n    }\n  }, [user]);\n\n  // Load referral history with user details\n  const loadReferralHistory = useCallback(async () => {\n    if (!user) return;\n\n    try {\n      const { data: referrals, error } = await supabase\n        .from('referrals')\n        .select(`\n          *,\n          referee:referee_id (\n            email,\n            user_metadata\n          )\n        `)\n        .eq('referrer_id', user.id)\n        .order('created_at', { ascending: false });\n\n      if (error) throw error;\n\n      const formattedHistory = referrals?.map(referral => ({\n        id: referral.id,\n        refereeName: referral.referee?.user_metadata?.username ||\n                    referral.referee?.email?.split('@')[0] ||\n                    'User',\n        refereeEmail: referral.referee?.email,\n        status: referral.status,\n        createdAt: referral.created_at,\n        completedAt: referral.completed_at,\n        rewardGiven: referral.referrer_reward_given,\n        wingsEarned: referral.referrer_wings_earned || 0\n      })) || [];\n\n      setReferralHistory(formattedHistory);\n\n    } catch (error) {\n      console.error('Error loading referral history:', error);\n      setError(error.message);\n    }\n  }, [user]);\n\n  // Process referral signup (called when someone signs up with a code)\n  const processReferralSignup = useCallback(async (referralCode, newUserId) => {\n    if (!referralCode || !newUserId) return;\n\n    try {\n      console.log('🔄 Processing referral signup:', { referralCode, newUserId });\n\n      // Find the referrer\n      const { data: codeData, error: codeError } = await supabase\n        .from('referral_codes')\n        .select('user_id')\n        .eq('referral_code', referralCode.toUpperCase())\n        .eq('is_active', true)\n        .single();\n\n      if (codeError || !codeData) {\n        console.warn('Invalid referral code:', referralCode);\n        return { success: false, error: 'Invalid referral code' };\n      }\n\n      // Don't allow self-referral\n      if (codeData.user_id === newUserId) {\n        console.warn('Self-referral attempt blocked');\n        return { success: false, error: 'Cannot refer yourself' };\n      }\n\n      let welcomeBonus = 25; // WINGS for joining via referral\n\n      // Create referral record\n      const { data: referralData, error: referralError } = await supabase\n        .from('referrals')\n        .insert([\n          {\n            referrer_id: codeData.user_id,\n            referee_id: newUserId,\n            referral_code: referralCode.toUpperCase(),\n            status: 'pending',\n            referee_wings_earned: welcomeBonus\n          }\n        ])\n        .select()\n        .single();\n\n      if (referralError) throw referralError;\n\n      // Award welcome bonus to referee using RPC\n      const { error: wingsError } = await supabase.rpc('add_wings_to_user', {\n        user_id_param: newUserId,\n        wings_amount: welcomeBonus,\n        activity_type_param: 'referral_bonus',\n        description_param: `Welcome bonus for joining via referral code: ${referralCode}`\n      });\n\n      if (wingsError) {\n        console.warn('Failed to award welcome bonus:', wingsError);\n      }\n\n      console.log('✅ Referral signup processed successfully');\n      return { success: true, data: referralData, bonusAmount: welcomeBonus };\n\n    } catch (error) {\n      console.error('Error processing referral signup:', error);\n      return { success: false, error: error.message };\n    }\n  }, []);\n\n  // Complete referral (called when referee completes their first action)\n  const completeReferral = useCallback(async (refereeId) => {\n    try {\n      console.log('🔄 Attempting to complete referral for referee:', refereeId);\n\n      // Find pending referral for this referee\n      const { data: referral, error: findError } = await supabase\n        .from('referrals')\n        .select('*')\n        .eq('referee_id', refereeId)\n        .eq('status', 'pending')\n        .single();\n\n      if (findError || !referral) {\n        console.log('No pending referral found for referee:', refereeId);\n        return { success: false, message: 'No pending referral found' };\n      }\n\n      let referrerReward = 50; // WINGS for successful referral\n      let refereeReward = 25;  // Additional WINGS for first action\n\n      // Update referral as completed\n      const { error: updateError } = await supabase\n        .from('referrals')\n        .update({\n          status: 'completed',\n          completed_at: new Date().toISOString(),\n          referrer_reward_given: true,\n          referee_reward_given: true,\n          referrer_wings_earned: referrerReward,\n          referee_wings_earned: (referral.referee_wings_earned || 0) + refereeReward\n        })\n        .eq('id', referral.id);\n\n      if (updateError) throw updateError;\n\n      // Award WINGS to both users using RPC\n      await Promise.all([\n        // Referrer reward\n        supabase.rpc('add_wings_to_user', {\n          user_id_param: referral.referrer_id,\n          wings_amount: referrerReward,\n          activity_type_param: 'referral',\n          description_param: `Referral completed - friend completed first scan`\n        }),\n        // Referee additional reward\n        supabase.rpc('add_wings_to_user', {\n          user_id_param: refereeId,\n          wings_amount: refereeReward,\n          activity_type_param: 'referral_bonus',\n          description_param: `First scan bonus - referred user reward`\n        })\n      ]);\n\n      // Update referrer's referral count\n      await supabase\n        .from('user_profiles')\n        .update({\n          total_referrals: supabase.raw('COALESCE(total_referrals, 0) + 1')\n        })\n        .eq('id', referral.referrer_id);\n\n      console.log('✅ Referral completed successfully');\n      return { success: true, referrerReward, refereeReward };\n\n    } catch (error) {\n      console.error('Error completing referral:', error);\n      return { success: false, error: error.message };\n    }\n  }, []);\n\n  // Generate referral link\n  const generateReferralLink = useCallback((code) => {\n    if (!code) return '';\n    const baseUrl = window.location.origin;\n    return `${baseUrl}/join/${code}`;\n  }, []);\n\n  // Share referral\n  const shareReferral = useCallback(async (code) => {\n    const referralLink = generateReferralLink(code);\n    \n    let shareText = `Join me on Monarch Passport! 🦋\\n\\nEarn exclusive fashion rewards by scanning QR codes. Use my code: ${code}`;\n    \n    if (navigator.share) {\n      try {\n        await navigator.share({\n          title: 'Join Monarch Passport',\n          text: shareText,\n          url: referralLink\n        });\n        return { success: true };\n      } catch (error) {\n        if (error.name !== 'AbortError') {\n          console.log('Share failed:', error);\n        }\n      }\n    }\n\n    // Fallback: copy to clipboard\n    try {\n      await navigator.clipboard.writeText(`${shareText}\\n\\n${referralLink}`);\n      return { success: true, copied: true };\n    } catch (error) {\n      console.error('Failed to copy to clipboard:', error);\n      return { success: false, link: referralLink };\n    }\n  }, [generateReferralLink]);\n\n  // Initialize\n  useEffect(() => {\n    console.log('🔧 useReferrals useEffect triggered, user:', user?.id);\n    \n    // Prevent unnecessary re-runs for the same user\n    if (user?.id === lastUserRef.current) {\n      console.log('🔄 Same user, skipping initialization');\n      return;\n    }\n    \n    lastUserRef.current = user?.id;\n    \n    if (user) {\n      console.log('✅ User found, calling ensureReferralCode...');\n      ensureReferralCode();\n      loadReferralStats();\n      loadReferralHistory();\n    } else {\n      console.log('❌ No user found, resetting referral state');\n      setReferralCode(null);\n      setReferralStats({\n        totalReferrals: 0,\n        pendingReferrals: 0,\n        completedReferrals: 0,\n        totalWingsEarned: 0\n      });\n      setReferralHistory([]);\n      setLoading(false);\n      setReferralLoading(false);\n      hasInitializedRef.current = false; // Reset for next user\n      isProcessingRef.current = false; // Reset for next user\n    }\n  }, [user, ensureReferralCode]); // Only depend on user, not the callback functions\n\n  // Cleanup timeouts on unmount\n  useEffect(() => {\n    return () => {\n      if (setReferralCodeTimeoutRef.current) {\n        clearTimeout(setReferralCodeTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  return {\n    referralCode,\n    referralStats,\n    referralHistory,\n    loading,\n    referralLoading,\n    setReferralLoading,\n    error,\n    processReferralSignup,\n    completeReferral,\n    generateReferralLink,\n    shareReferral,\n    refreshData: () => {\n      loadReferralStats();\n      loadReferralHistory();\n    }\n  };\n};"],"names":["SHOPIFY_CONFIG","baseUrl","imageBaseUrl","imageSuffix","defaultImageSize","altImageSize","MONARCH_COLORS","primary","secondary","accent","dark","light","gradient","monarch","chrysalis","nectar","wing","EXCLUSIVITY_LEVELS","ultra_rare","name","description","color","multiplier","legendary","mythic","generateShopifyImage","productId","imageId","filename","alt","arguments","length","undefined","id","src","concat","Date","now","width","height","srcSet","small","medium","large","createLimitedEdition","totalSupply","bonusWings","exclusivityLevel","endDate","isActive","MONARCH_REWARDS","MONARCH_VARSITY_JACKET","rewardId","category","rarity","wingsValue","season","shopifyProductId","shopifyPrice","shopifyHandle","limitedEdition","images","metadata","material","fit","features","care","sustainability","GOLDEN_MONARCH_CHAIN","chainLength","pendantSize","exclusivity","CHRYSALIS_COLLECTION_HOODIE","NECTAR_COLLECTION_TEE","CLASSIC_MONARCH_TEE","MONARCH_SNAPBACK","WING_COLLECTION_PINS","setSize","collectibility","BLOOM_COLLECTION_HOODIE","POLLINATE_COLLECTION_BAG","dimensions","MONARCH_SNAPBACK_CAP","MONARCH_PIN_SET","MONARCH_BACKPACK","RewardUtils","getActiveRewards","Object","values","filter","reward","getLimitedEditionRewards","getRegularRewards","getRewardById","getRewardsByCategory","getRewardsByRarity","getRewardsBySeason","isLimitedEdition","getLimitedEditionConfig","getTotalWingsValue","_reward$limitedEditio","getShopifyUrl","getPrimaryImage","_reward$images","getExclusivityLevel","level","getAllExclusivityLevels","getMonarchColors","supabase","createClient","process","useMonarchRewards","rewards","setRewards","useState","loading","setLoading","error","setError","userRewards","setUserRewards","userLoading","setUserLoading","activeLimitedEditions","userClaims","claimLimitedEdition","hasUserClaimed","getUserMintNumber","limitedEditionLoading","limitedEditionError","useLimitedEditions","setActiveLimitedEditions","setUserClaims","fetchActiveLimitedEditions","useCallback","async","data","rpc","err","console","message","fetchUserClaims","user","auth","getUser","p_user_id","qrScanLocation","Error","p_reward_id","p_qr_scan_location","result","success","Promise","all","mintNumber","mint_number","claimedAt","claimed_at","getLimitedEditionStatus","some","claim","reward_id","find","useEffect","loadData","refresh","totalUserClaims","availableLimitedEditions","item","available_count","loadRewards","allRewards","rewardsWithStatus","limitedEditionStatus","le","total_supply","claimedCount","claimed_count","availableCount","claimPercentage","claim_percentage","daysRemaining","days_remaining","push","_objectSpread","userHasClaimed","userMintNumber","totalWingsValue","shopifyUrl","primaryImage","loadUserRewards","from","select","eq","order","ascending","enhancedUserRewards","map","userReward","staticReward","staticData","wings_earned","claimReward","overallTimeout","_","reject","setTimeout","claimOperation","insert","user_id","earned_date","toISOString","earned_via","qr_scan_location","static_reward_id","single","code","update","wings_balance","raw","updated_at","log","timeoutPromise","race","refreshError","warn","getUserLimitedEditions","getUserRegularRewards","canUserClaim","r","getRewardStats","totalRewards","limitedEditions","regularRewards","userTotalRewards","userLimitedEditions","userRegularRewards","reduce","sum","userTotalWings","stats","limitedEditionReveal","keyframes","_templateObject","_taggedTemplateLiteral","mintNumberGlow","_templateObject2","exclusivityPulse","_templateObject3","sparkleAnimation","_templateObject4","valueGlow","_templateObject5","Container","styled","div","_templateObject6","ModalCard","GlassCard","_templateObject7","props","exclusivityColor","ExclusivityBadge","_templateObject8","MintNumberContainer","_templateObject9","MintNumberBadge","_templateObject0","SupplyInfo","_templateObject1","SupplyItem","_templateObject10","_ref","theme","colors","text","_ref2","isHighlighted","_ref3","RewardImage","_templateObject11","imageUrl","RewardTitle","h2","_templateObject12","_ref4","typography","fontFamily","heading","_ref5","RewardDescription","p","_templateObject13","_ref6","WingsEarned","_templateObject14","_ref7","gold","_ref8","CollectionValue","_templateObject15","ValueTitle","h3","_templateObject16","_ref9","ValueDescription","_templateObject17","_ref0","SocialSharing","_templateObject18","SocialTitle","_templateObject19","SocialDescription","_templateObject20","_ref1","ShareButton","button","_templateObject21","ClaimedAt","_templateObject22","_ref10","ButtonContainer","_templateObject23","ViewInClosetButton","GlowButton","_templateObject24","CloseButton","_templateObject25","_ref11","_ref12","_ref13","_ref14","_ref15","_images$","claimResult","onClose","onShowInCloset","shareAttempted","setShareAttempted","availability","baseWings","formatClaimedDate","dateString","toLocaleDateString","year","month","day","hour","minute","_jsx","onClick","role","children","_jsxs","e","stopPropagation","replace","toUpperCase","className","toFixed","getCollectionValueMessage","percentage","shareText","shareUrl","window","location","origin","navigator","share","title","url","clipboard","writeText","disabled","checkLimitedEditionAvailability","available","reason","status","isAvailable","is_active","startDate","start_date","end_date","user_has_claimed","user_mint_number","claimLimitedEditionItem","userId","processLimitedEditionQR","qrData","_await$supabase$from$","existingClaim","maybeSingle","activity_type","activity_title","activity_description","limitedEditionId","activityError","validateLimitedEditionQR","qrText","payload","JSON","parse","type","valid","timestamp","rewardReveal","background","ScannerCard","LoadingOverlay","RewardModal","RewardIcon","ErrorCard","LoadingProgressBar","LoadingProgressFill","progress","LoadingSpinner","StateTransition","visible","ConnectionIndicator","quality","ClaimButton","claimed","SecondaryButton","QuestUpdateBanner","CheckMark","EnhancedRewardModal","claimState","setClaimState","questUpdate","setQuestUpdate","showQuestUpdate","setShowQuestUpdate","questName","newProgress","total","completed","_Fragment","jackets","tops","bottoms","headwear","accessories","footwear","themes","style","marginBottom","wingsEarned","resolve","questProgress","rewardCategory","questData","scanQuest","q","quest_type","current_progress","isCompleted","target_value","completed_at","quest_title","oldProgress","checkQuestProgress","fontSize","ScanScreen","navigate","useNavigate","useAuth","awardQRStamp","awardFirstItemStamp","awardStyleStamp","hasStamp","useStamps","completeReferral","useReferrals","claimMonarchReward","isScanning","setIsScanning","isLoading","setIsLoading","cameraInitialized","setCameraInitialized","cameraInitializing","setCameraInitializing","setReward","cameraError","setCameraError","isProcessing","setIsProcessing","limitedEditionResult","setLimitedEditionResult","showLimitedEditionModal","setShowLimitedEditionModal","qrLibraryLoaded","setQrLibraryLoaded","qrLibraryError","setQrLibraryError","loadingProgress","setLoadingProgress","retryCount","setRetryCount","connectionQuality","setConnectionQuality","qrCodeScannerRef","useRef","qrLibraryRef","scannerElementId","checkConnectionQuality","connection","effectiveType","loadQRLibrary","prev","progressInterval","setInterval","Math","min","importPromise","Html5Qrcode","Html5QrcodeScanType","current","clearInterval","errorMessage","includes","validateQRPayload","checkExistingReward","exists","fetchReward","generateMintNumber","limit","floor","random","addToCloset","rewardData","item_type","wings_value","updateWingsBalance","wingsToAdd","currentBalance","newBalance","logActivity","activityData","rewardName","handleScanSuccess","stopScanning","securityResult","enhancedSecurity","enhancedQRScan","scanType","userAgent","trackSuspiciousActivity","substring","validation","stampError","claimPromise","_staticReward$categor","toLowerCase","closetItems","closetError","uniqueCategories","Set","forEach","_item$rewards","add","size","styleCheckError","referralResult","referrerReward","referralError","vibrate","simplifiedScanFunction","decodedText","decodedResult","startScanning","isLocalDevelopment","hostname","startsWith","protocol","mediaDevices","getUserMedia","stream","devices","video","facingMode","getTracks","track","stop","permissionError","getCameras","deviceError","document","getElementById","qrCodeScanner","mobileConfig","fps","qrbox","aspectRatio","disableFlip","supportedScanTypes","SCAN_TYPE_CAMERA","cameraId","backCamera","device","label","start","startError","clear","handleStartScanning","vendor","opera","test","handleCloseLimitedEditionModal","lineHeight","display","gap","justifyContent","flexWrap","borderColor","cursor","reload","padding","marginTop","position","top","left","zIndex","transform","pointerEvents","border","borderRadius","borderTop","borderLeft","borderTopLeftRadius","right","borderRight","borderTopRightRadius","bottom","borderBottom","borderBottomLeftRadius","borderBottomRightRadius","animation","textAlign","maxWidth","backdropFilter","flexDirection","alignItems","handleRetryCamera","handleTryAgain","LimitedEditionRewardModal","handleShowLimitedEditionInCloset","referralCode","setReferralCode","referralStats","setReferralStats","totalReferrals","pendingReferrals","completedReferrals","totalWingsEarned","referralHistory","setReferralHistory","referralLoading","setReferralLoading","hasInitializedRef","isProcessingRef","lastUserRef","setReferralCodeTimeoutRef","ensureReferralCode","_user$user_metadata","_user$email","shortCode","user_metadata","username","email","split","randomSuffix","toString","cachedCode","localStorage","getItem","parsed","finalCode","dbCode","dbError","queryPromise","profile","referral_code","timeoutError","generateLocalReferralCode","setItem","stringify","fallbackCode","loadReferralStats","referrals","referralsError","profileError","referral_wings_earned","loadReferralHistory","formattedHistory","referral","_referral$referee","_referral$referee$use","_referral$referee2","_referral$referee2$em","_referral$referee3","refereeName","referee","refereeEmail","createdAt","created_at","completedAt","rewardGiven","referrer_reward_given","referrer_wings_earned","processReferralSignup","newUserId","codeData","codeError","welcomeBonus","referralData","referrer_id","referee_id","referee_wings_earned","wingsError","user_id_param","wings_amount","activity_type_param","description_param","bonusAmount","refereeId","findError","refereeReward","updateError","referee_reward_given","total_referrals","generateReferralLink","shareReferral","referralLink","copied","link","clearTimeout","refreshData"],"sourceRoot":""}