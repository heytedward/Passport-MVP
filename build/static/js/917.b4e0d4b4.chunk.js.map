{"version":3,"file":"static/js/917.b4e0d4b4.chunk.js","mappings":"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","sources":["utils/rewardIntegration.js"],"sourcesContent":["/**\n * Reward Integration Utilities\n * PapillonLabs Monarch Passport MVP\n * \n * This module provides utilities for integrating static rewards configuration\n * with the limited edition tracking system and database operations.\n */\n\nimport { createClient } from '@supabase/supabase-js';\nimport MONARCH_REWARDS, { RewardUtils } from '../config/monarchRewards';\n\nconst supabase = createClient(\n  process.env.REACT_APP_SUPABASE_URL,\n  process.env.REACT_APP_SUPABASE_ANON_KEY\n);\n\n/**\n * Initialize limited edition items in database from static configuration\n */\nexport const initializeLimitedEditions = async () => {\n  try {\n    console.log('🦋 Initializing limited edition items from static configuration...');\n    \n    const limitedEditionRewards = RewardUtils.getLimitedEditionRewards();\n    const results = [];\n\n    for (const reward of limitedEditionRewards) {\n      try {\n        // Check if limited edition already exists\n        const { data: existing } = await supabase\n          .from('limited_edition_items')\n          .select('id')\n          .eq('reward_id', reward.rewardId)\n          .single();\n\n        if (existing) {\n          console.log(`✅ Limited edition already exists: ${reward.rewardId}`);\n          results.push({ rewardId: reward.rewardId, status: 'exists' });\n          continue;\n        }\n\n        // Create limited edition item\n        const { data, error } = await supabase\n          .rpc('create_limited_edition_item', {\n            p_reward_id: reward.rewardId,\n            p_total_supply: reward.limitedEdition.totalSupply,\n            p_start_date: new Date().toISOString(),\n            p_end_date: reward.limitedEdition.endDate || null\n          });\n\n        if (error) {\n          console.error(`❌ Error creating limited edition ${reward.rewardId}:`, error);\n          results.push({ rewardId: reward.rewardId, status: 'error', error: error.message });\n        } else {\n          console.log(`✅ Created limited edition: ${reward.rewardId} (${reward.limitedEdition.totalSupply} pieces)`);\n          results.push({ rewardId: reward.rewardId, status: 'created', itemId: data });\n        }\n      } catch (err) {\n        console.error(`❌ Error processing limited edition ${reward.rewardId}:`, err);\n        results.push({ rewardId: reward.rewardId, status: 'error', error: err.message });\n      }\n    }\n\n    return results;\n  } catch (error) {\n    console.error('❌ Error initializing limited editions:', error);\n    throw error;\n  }\n};\n\n/**\n * Sync static rewards with database\n */\nexport const syncStaticRewards = async () => {\n  try {\n    console.log('🦋 Syncing static rewards with database...');\n    \n    const allRewards = RewardUtils.getActiveRewards();\n    const results = [];\n\n    for (const reward of allRewards) {\n      try {\n        // Check if reward exists in static_rewards table\n        const { data: existing } = await supabase\n          .from('static_rewards')\n          .select('reward_id')\n          .eq('reward_id', reward.rewardId)\n          .single();\n\n        if (existing) {\n          console.log(`✅ Static reward already exists: ${reward.rewardId}`);\n          results.push({ rewardId: reward.rewardId, status: 'exists' });\n          continue;\n        }\n\n        // Create static reward record\n        const { error } = await supabase\n          .from('static_rewards')\n          .insert({\n            reward_id: reward.rewardId,\n            name: reward.name,\n            description: reward.description,\n            category: reward.category,\n            rarity: reward.rarity,\n            wings_value: reward.wingsValue,\n            season: reward.season,\n            is_active: reward.isActive,\n            data: {\n              shopifyProductId: reward.shopifyProductId,\n              shopifyPrice: reward.shopifyPrice,\n              shopifyHandle: reward.shopifyHandle,\n              images: reward.images,\n              metadata: reward.metadata,\n              limitedEdition: reward.limitedEdition\n            }\n          });\n\n        if (error) {\n          console.error(`❌ Error creating static reward ${reward.rewardId}:`, error);\n          results.push({ rewardId: reward.rewardId, status: 'error', error: error.message });\n        } else {\n          console.log(`✅ Created static reward: ${reward.rewardId}`);\n          results.push({ rewardId: reward.rewardId, status: 'created' });\n        }\n      } catch (err) {\n        console.error(`❌ Error processing static reward ${reward.rewardId}:`, err);\n        results.push({ rewardId: reward.rewardId, status: 'error', error: err.message });\n      }\n    }\n\n    return results;\n  } catch (error) {\n    console.error('❌ Error syncing static rewards:', error);\n    throw error;\n  }\n};\n\n/**\n * Get reward data with limited edition status\n */\nexport const getRewardWithLimitedEditionStatus = async (rewardId) => {\n  try {\n    // Get static reward data\n    const staticReward = RewardUtils.getRewardById(rewardId);\n    if (!staticReward) {\n      throw new Error(`Reward not found: ${rewardId}`);\n    }\n\n    // Get limited edition status if applicable\n    let limitedEditionStatus = null;\n    if (staticReward.limitedEdition) {\n      const { data, error } = await supabase\n        .rpc('get_limited_edition_status', { p_reward_id: rewardId });\n\n      if (error) {\n        console.error(`Error getting limited edition status for ${rewardId}:`, error);\n      } else if (data && data.length > 0) {\n        limitedEditionStatus = data[0];\n      }\n    }\n\n    return {\n      ...staticReward,\n      limitedEditionStatus\n    };\n  } catch (error) {\n    console.error(`Error getting reward with limited edition status for ${rewardId}:`, error);\n    throw error;\n  }\n};\n\n/**\n * Get all rewards with limited edition status\n */\nexport const getAllRewardsWithStatus = async () => {\n  try {\n    const allRewards = RewardUtils.getActiveRewards();\n    const results = [];\n\n    for (const reward of allRewards) {\n      try {\n        const rewardWithStatus = await getRewardWithLimitedEditionStatus(reward.rewardId);\n        results.push(rewardWithStatus);\n      } catch (err) {\n        console.error(`Error getting status for ${reward.rewardId}:`, err);\n        results.push({ ...reward, limitedEditionStatus: null, error: err.message });\n      }\n    }\n\n    return results;\n  } catch (error) {\n    console.error('Error getting all rewards with status:', error);\n    throw error;\n  }\n};\n\n/**\n * Validate reward configuration\n */\nexport const validateRewardConfiguration = () => {\n  const errors = [];\n  const warnings = [];\n\n  const allRewards = RewardUtils.getActiveRewards();\n\n  // Check for duplicate reward IDs\n  const rewardIds = allRewards.map(r => r.rewardId);\n  const duplicates = rewardIds.filter((id, index) => rewardIds.indexOf(id) !== index);\n  if (duplicates.length > 0) {\n    errors.push(`Duplicate reward IDs found: ${duplicates.join(', ')}`);\n  }\n\n  // Check for valid Shopify configurations\n  allRewards.forEach(reward => {\n    if (!reward.shopifyProductId) {\n      warnings.push(`Missing Shopify product ID for ${reward.rewardId}`);\n    }\n    if (!reward.shopifyPrice || reward.shopifyPrice <= 0) {\n      warnings.push(`Invalid Shopify price for ${reward.rewardId}`);\n    }\n    if (reward.images.length === 0) {\n      warnings.push(`No images configured for ${reward.rewardId}`);\n    }\n  });\n\n  // Check limited edition configurations\n  const limitedEditions = RewardUtils.getLimitedEditionRewards();\n  limitedEditions.forEach(reward => {\n    const config = reward.limitedEdition;\n    if (config.totalSupply <= 0) {\n      errors.push(`Invalid total supply for ${reward.rewardId}`);\n    }\n    if (config.bonusWings < 0) {\n      errors.push(`Invalid bonus WINGS for ${reward.rewardId}`);\n    }\n    if (config.endDate && new Date(config.endDate) <= new Date()) {\n      warnings.push(`End date has passed for ${reward.rewardId}`);\n    }\n  });\n\n  return { errors, warnings, isValid: errors.length === 0 };\n};\n\n/**\n * Get reward analytics\n */\nexport const getRewardAnalytics = async () => {\n  try {\n    const allRewards = RewardUtils.getActiveRewards();\n    const limitedEditions = RewardUtils.getLimitedEditionRewards();\n    const regularRewards = RewardUtils.getRegularRewards();\n\n    // Get limited edition analytics from database\n    const { data: limitedEditionAnalytics, error } = await supabase\n      .from('limited_edition_analytics')\n      .select('*');\n\n    if (error) {\n      console.error('Error fetching limited edition analytics:', error);\n    }\n\n    return {\n      totalRewards: allRewards.length,\n      limitedEditionRewards: limitedEditions.length,\n      regularRewards: regularRewards.length,\n      totalWingsValue: allRewards.reduce((sum, reward) => sum + RewardUtils.getTotalWingsValue(reward.rewardId), 0),\n      limitedEditionAnalytics: limitedEditionAnalytics || [],\n      categories: [...new Set(allRewards.map(r => r.category))],\n      rarities: [...new Set(allRewards.map(r => r.rarity))],\n      seasons: [...new Set(allRewards.map(r => r.season))]\n    };\n  } catch (error) {\n    console.error('Error getting reward analytics:', error);\n    throw error;\n  }\n};\n\n/**\n * Export reward data for external systems\n */\nexport const exportRewardData = (format = 'json') => {\n  try {\n    const allRewards = RewardUtils.getActiveRewards();\n    \n    switch (format.toLowerCase()) {\n      case 'json':\n        return JSON.stringify(allRewards, null, 2);\n      \n      case 'csv':\n        const headers = ['rewardId', 'name', 'category', 'rarity', 'wingsValue', 'season', 'isLimitedEdition', 'totalSupply', 'shopifyPrice'];\n        const rows = allRewards.map(reward => [\n          reward.rewardId,\n          reward.name,\n          reward.category,\n          reward.rarity,\n          reward.wingsValue,\n          reward.season,\n          reward.limitedEdition ? 'Yes' : 'No',\n          reward.limitedEdition?.totalSupply || 'N/A',\n          reward.shopifyPrice\n        ]);\n        \n        return [headers, ...rows]\n          .map(row => row.map(field => `\"${field}\"`).join(','))\n          .join('\\n');\n      \n      default:\n        throw new Error(`Unsupported export format: ${format}`);\n    }\n  } catch (error) {\n    console.error('Error exporting reward data:', error);\n    throw error;\n  }\n};\n\n/**\n * Import reward data from external sources\n */\nexport const importRewardData = async (data, format = 'json') => {\n  try {\n    let parsedData;\n    \n    switch (format.toLowerCase()) {\n      case 'json':\n        parsedData = typeof data === 'string' ? JSON.parse(data) : data;\n        break;\n      \n      case 'csv':\n        // Basic CSV parsing - in production, use a proper CSV library\n        const lines = data.split('\\n');\n        const headers = lines[0].split(',').map(h => h.replace(/\"/g, ''));\n        parsedData = lines.slice(1).map(line => {\n          const values = line.split(',').map(v => v.replace(/\"/g, ''));\n          return headers.reduce((obj, header, index) => {\n            obj[header] = values[index];\n            return obj;\n          }, {});\n        });\n        break;\n      \n      default:\n        throw new Error(`Unsupported import format: ${format}`);\n    }\n\n    console.log(`🦋 Importing ${parsedData.length} rewards...`);\n    \n    // Validate and process imported data\n    const results = [];\n    for (const item of parsedData) {\n      try {\n        // Basic validation\n        if (!item.rewardId || !item.name) {\n          results.push({ rewardId: item.rewardId || 'unknown', status: 'error', error: 'Missing required fields' });\n          continue;\n        }\n\n        // Process the imported item\n        // This would typically involve creating/updating database records\n        results.push({ rewardId: item.rewardId, status: 'imported' });\n      } catch (err) {\n        results.push({ rewardId: item.rewardId || 'unknown', status: 'error', error: err.message });\n      }\n    }\n\n    return results;\n  } catch (error) {\n    console.error('Error importing reward data:', error);\n    throw error;\n  }\n};\n\n// Export utility functions\nexport const RewardIntegration = {\n  initializeLimitedEditions,\n  syncStaticRewards,\n  getRewardWithLimitedEditionStatus,\n  getAllRewardsWithStatus,\n  validateRewardConfiguration,\n  getRewardAnalytics,\n  exportRewardData,\n  importRewardData\n};\n\nexport default RewardIntegration; "],"names":["supabase","createClient","process","initializeLimitedEditions","async","console","log","limitedEditionRewards","RewardUtils","getLimitedEditionRewards","results","reward","data","existing","from","select","eq","rewardId","single","concat","push","status","error","rpc","p_reward_id","p_total_supply","limitedEdition","totalSupply","p_start_date","Date","toISOString","p_end_date","endDate","message","itemId","err","syncStaticRewards","allRewards","getActiveRewards","insert","reward_id","name","description","category","rarity","wings_value","wingsValue","season","is_active","isActive","shopifyProductId","shopifyPrice","shopifyHandle","images","metadata","validateRewardConfiguration","errors","warnings","rewardIds","map","r","duplicates","filter","id","index","indexOf","length","join","forEach","config","bonusWings","isValid","getRewardAnalytics","limitedEditions","regularRewards","getRegularRewards","limitedEditionAnalytics","totalRewards","totalWingsValue","reduce","sum","getTotalWingsValue","categories","Set","rarities","seasons"],"sourceRoot":""}